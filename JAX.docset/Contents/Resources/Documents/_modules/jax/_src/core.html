
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>jax._src.core &#8212; JAX  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../../../_static/style.css?v=02ed413a" />
    <link rel="stylesheet" href="../../../_static/style.css" type="text/css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script src="../../../_static/design-tabs.js?v=36754332"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/jax/_src/core';</script>
    <link rel="icon" href="../../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/jax_logo_250px.png" class="logo__image only-light" alt="JAX  documentation - Home"/>
    <script>document.write(`<img src="../../../_static/jax_logo_250px.png" class="logo__image only-dark" alt="JAX  documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing JAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/quickstart.html">JAX Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/thinking_in_jax.html">How to Think in JAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Common_Gotchas_in_JAX.html">ðŸ”ª JAX - The Sharp Bits ðŸ”ª</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">JAX Frequently Asked Questions (FAQ)</a></li>
</ul>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../jax-101/index.html">Tutorial: JAX 101</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../jax-101/01-jax-basics.html">JAX As Accelerated NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax-101/02-jitting.html">Just In Time Compilation with JAX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax-101/03-vectorization.html">Automatic Vectorization in JAX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax-101/04-advanced-autodiff.html">Advanced Automatic Differentiation in JAX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax-101/05-random-numbers.html">Pseudo Random Numbers in JAX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax-101/05.1-pytrees.html">Working with Pytrees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax-101/06-parallelism.html">Parallel Evaluation in JAX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax-101/07-state.html">Stateful Computations in JAX</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Further Resources</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../user_guides.html">User Guides</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../profiling.html">Profiling JAX programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../device_memory_profiling.html">Device Memory Profiling</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../debugging/index.html">Runtime value debugging in JAX</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../debugging/print_breakpoint.html"><code class="docutils literal notranslate"><span class="pre">jax.debug.print</span></code> and <code class="docutils literal notranslate"><span class="pre">jax.debug.breakpoint</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../debugging/checkify_guide.html">The <code class="docutils literal notranslate"><span class="pre">checkify</span></code> transformation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../debugging/flags.html">JAX debugging flags</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../gpu_performance_tips.html">GPU performance tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../persistent_compilation_cache.html">Persistent Compilation Cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jaxpr.html">Understanding Jaxprs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/external_callbacks.html">External Callbacks in JAX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../type_promotion.html">Type promotion semantics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../pytrees.html">Pytrees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../aot.html">Ahead-of-time lowering and compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../errors.html">JAX Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../transfer_guard.html">Transfer guard</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../pallas/index.html">Pallas: a JAX kernel language</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../pallas/design.html">Pallas Design</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../pallas/quickstart.html">Pallas Quickstart</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../pallas/tpu/index.html">Pallas TPU</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../pallas/tpu/details.html">Writing TPU kernels with Pallas</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../pallas/tpu/pipelining.html">Pipelining and <code class="docutils literal notranslate"><span class="pre">BlockSpec</span></code>s</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../advanced_guide.html">Advanced Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/neural_network_with_tfds_data.html">Training a Simple Neural Network, with tensorflow/datasets Data Loading</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/Neural_Network_and_Data_Loading.html">Training a Simple Neural Network, with PyTorch Data Loading</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/vmapped_log_probs.html">Autobatching for Bayesian Inference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../multi_process.html">Using JAX in multi-host and multi-process environments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/Distributed_arrays_and_automatic_parallelization.html">Distributed arrays and automatic parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/shard_map.html">SPMD multi-device parallelism with <code class="docutils literal notranslate"><span class="pre">shard_map</span></code></a></li>



<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/xmap_tutorial.html">Named axes and easy-to-revise parallelism with <code class="docutils literal notranslate"><span class="pre">xmap</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/autodiff_cookbook.html">The Autodiff Cookbook</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/Custom_derivative_rules_for_Python_code.html">Custom derivative rules for JAX-transformable Python functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/autodiff_remat.html">Control autodiffâ€™s saved values with <code class="docutils literal notranslate"><span class="pre">jax.checkpoint</span></code> (aka <code class="docutils literal notranslate"><span class="pre">jax.remat</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/How_JAX_primitives_work.html">How JAX primitives work</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/Writing_custom_interpreters_in_Jax.html">Writing custom Jaxpr interpreters in JAX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../Custom_Operation_for_GPUs.html">Custom operations for GPUs with C++ and CUDA</a></li>

<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/convolutions.html">Generalized Convolutions in JAX</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../contributor_guide.html">Developer Documentation</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html">Contributing to JAX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../developer.html">Building from source</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax_internal_api.html">Internal APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../autodidax.html">Autodidax: JAX core from scratch</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../jep/index.html">JAX Enhancement Proposals (JEPs)</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/263-prng.html">263: JAX PRNG Design</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/2026-custom-derivatives.html">2026: Custom JVP/VJP rules for JAX-transformable functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/4008-custom-vjp-update.html">4008: Custom VJP and `nondiff_argnums` update</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/4410-omnistaging.html">4410: Omnistaging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/9263-typed-keys.html">9263: Typed keys &amp; pluggable RNGs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/9407-type-promotion.html">9407: Design of Type Promotion Semantics for JAX</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/9419-jax-versioning.html">9419: Jax and Jaxlib versioning</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/10657-sequencing-effects.html">10657: Sequencing side-effects in JAX</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/11830-new-remat-checkpoint.html">11830: `jax.remat` / `jax.checkpoint` new implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/12049-type-annotations.html">12049: Type Annotation Roadmap for JAX</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/14273-shard-map.html">14273: `shard_map` (`shmap`) for simple per-device code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/15856-jex.html">15856: `jax.extend`, an extensions module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/17111-shmap-transpose.html">17111: Efficient transposition of `shard_map` (and other maps)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jep/18137-numpy-scipy-scope.html">18137: Scope of JAX NumPy &amp; SciPy Wrappers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../investigating_a_regression.html">Investigating a regression</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../building_on_jax.html">Building on JAX</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../notes.html">Notes</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api_compatibility.html">API compatibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../deprecation.html">Python and NumPy version support policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax_array_migration.html">jax.Array migration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../async_dispatch.html">Asynchronous dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../gpu_memory_allocation.html">GPU memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../rank_promotion_warning.html">Rank promotion warning</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../jax.html">Public API: jax package</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../jax.numpy.html"><code class="docutils literal notranslate"><span class="pre">jax.numpy</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-11"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.fft.html">jax.numpy.fft.fft</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.fft2.html">jax.numpy.fft.fft2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.fftfreq.html">jax.numpy.fft.fftfreq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.fftn.html">jax.numpy.fft.fftn</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.fftshift.html">jax.numpy.fft.fftshift</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.hfft.html">jax.numpy.fft.hfft</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.ifft.html">jax.numpy.fft.ifft</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.ifft2.html">jax.numpy.fft.ifft2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.ifftn.html">jax.numpy.fft.ifftn</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.ifftshift.html">jax.numpy.fft.ifftshift</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.ihfft.html">jax.numpy.fft.ihfft</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.irfft.html">jax.numpy.fft.irfft</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.irfft2.html">jax.numpy.fft.irfft2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.irfftn.html">jax.numpy.fft.irfftn</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.rfft.html">jax.numpy.fft.rfft</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.rfft2.html">jax.numpy.fft.rfft2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.rfftfreq.html">jax.numpy.fft.rfftfreq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.numpy.fft.rfftn.html">jax.numpy.fft.rfftn</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../jax.scipy.html"><code class="docutils literal notranslate"><span class="pre">jax.scipy</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-12"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.scipy.stats.bernoulli.logpmf.html">jax.scipy.stats.bernoulli.logpmf</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.scipy.stats.bernoulli.pmf.html">jax.scipy.stats.bernoulli.pmf</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.scipy.stats.bernoulli.cdf.html">jax.scipy.stats.bernoulli.cdf</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/jax.scipy.stats.bernoulli.ppf.html">jax.scipy.stats.bernoulli.ppf</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.lax.html"><code class="docutils literal notranslate"><span class="pre">jax.lax</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.random.html"><code class="docutils literal notranslate"><span class="pre">jax.random</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.sharding.html"><code class="docutils literal notranslate"><span class="pre">jax.sharding</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.debug.html"><code class="docutils literal notranslate"><span class="pre">jax.debug</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.dlpack.html"><code class="docutils literal notranslate"><span class="pre">jax.dlpack</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.distributed.html"><code class="docutils literal notranslate"><span class="pre">jax.distributed</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.dtypes.html"><code class="docutils literal notranslate"><span class="pre">jax.dtypes</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.flatten_util.html"><code class="docutils literal notranslate"><span class="pre">jax.flatten_util</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.image.html"><code class="docutils literal notranslate"><span class="pre">jax.image</span></code> module</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../jax.nn.html"><code class="docutils literal notranslate"><span class="pre">jax.nn</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-13"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.nn.initializers.html"><code class="docutils literal notranslate"><span class="pre">jax.nn.initializers</span></code> module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.ops.html"><code class="docutils literal notranslate"><span class="pre">jax.ops</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.profiler.html"><code class="docutils literal notranslate"><span class="pre">jax.profiler</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.stages.html"><code class="docutils literal notranslate"><span class="pre">jax.stages</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.tree.html"><code class="docutils literal notranslate"><span class="pre">jax.tree</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.tree_util.html"><code class="docutils literal notranslate"><span class="pre">jax.tree_util</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.typing.html"><code class="docutils literal notranslate"><span class="pre">jax.typing</span></code> module</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../jax.extend.html"><code class="docutils literal notranslate"><span class="pre">jax.extend</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-14"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.extend.linear_util.html"><code class="docutils literal notranslate"><span class="pre">jax.extend.linear_util</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.extend.mlir.html"><code class="docutils literal notranslate"><span class="pre">jax.extend.mlir</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.extend.random.html"><code class="docutils literal notranslate"><span class="pre">jax.extend.random</span></code> module</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../jax.example_libraries.html"><code class="docutils literal notranslate"><span class="pre">jax.example_libraries</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-15"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.example_libraries.optimizers.html"><code class="docutils literal notranslate"><span class="pre">jax.example_libraries.optimizers</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.example_libraries.stax.html"><code class="docutils literal notranslate"><span class="pre">jax.example_libraries.stax</span></code> module</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../jax.experimental.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-16"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.experimental.array_api.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.array_api</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.experimental.checkify.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.checkify</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.experimental.host_callback.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.host_callback</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.experimental.maps.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.maps</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.experimental.pjit.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.pjit</span></code> module</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../jax.experimental.sparse.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.sparse</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-17"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.BCOO.html">jax.experimental.sparse.BCOO</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_broadcast_in_dim.html">jax.experimental.sparse.bcoo_broadcast_in_dim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_concatenate.html">jax.experimental.sparse.bcoo_concatenate</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_dot_general.html">jax.experimental.sparse.bcoo_dot_general</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_dot_general_sampled.html">jax.experimental.sparse.bcoo_dot_general_sampled</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_dynamic_slice.html">jax.experimental.sparse.bcoo_dynamic_slice</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_extract.html">jax.experimental.sparse.bcoo_extract</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_fromdense.html">jax.experimental.sparse.bcoo_fromdense</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_gather.html">jax.experimental.sparse.bcoo_gather</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_multiply_dense.html">jax.experimental.sparse.bcoo_multiply_dense</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_multiply_sparse.html">jax.experimental.sparse.bcoo_multiply_sparse</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_update_layout.html">jax.experimental.sparse.bcoo_update_layout</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_reduce_sum.html">jax.experimental.sparse.bcoo_reduce_sum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_reshape.html">jax.experimental.sparse.bcoo_reshape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_slice.html">jax.experimental.sparse.bcoo_slice</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_sort_indices.html">jax.experimental.sparse.bcoo_sort_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_squeeze.html">jax.experimental.sparse.bcoo_squeeze</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_sum_duplicates.html">jax.experimental.sparse.bcoo_sum_duplicates</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_todense.html">jax.experimental.sparse.bcoo_todense</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/jax.experimental.sparse.bcoo_transpose.html">jax.experimental.sparse.bcoo_transpose</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.experimental.jet.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.jet</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.experimental.custom_partitioning.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.custom_partitioning</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.experimental.multihost_utils.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.multihost_utils</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.experimental.compilation_cache.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.compilation_cache</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.experimental.key_reuse.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.key_reuse</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../jax.experimental.mesh_utils.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.mesh_utils</span></code> module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../jax.lib.html"><code class="docutils literal notranslate"><span class="pre">jax.lib</span></code> module</a></li>
</ul>
</li>
</ul>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Change log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">JAX Glossary of Terms</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/google/jax" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for jax._src.core</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2018 The JAX Authors.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">collections</span>  <span class="c1"># noqa: F401</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Collection</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span>
                             <span class="n">Iterator</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">MutableSet</span><span class="p">,</span>
                             <span class="n">MutableMapping</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">partialmethod</span><span class="p">,</span> <span class="n">total_ordering</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">ClassVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span>
                    <span class="n">cast</span><span class="p">,</span> <span class="n">overload</span><span class="p">,</span> <span class="n">Union</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">weakref</span> <span class="kn">import</span> <span class="n">ref</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">effects</span>
<span class="kn">from</span> <span class="nn">jax._src.errors</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ConcretizationTypeError</span><span class="p">,</span> <span class="n">TracerArrayConversionError</span><span class="p">,</span> <span class="n">TracerBoolConversionError</span><span class="p">,</span>
    <span class="n">TracerIntegerConversionError</span><span class="p">,</span> <span class="n">UnexpectedTracerError</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">linear_util</span> <span class="k">as</span> <span class="n">lu</span>

<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">source_info_util</span>
<span class="kn">from</span> <span class="nn">jax._src.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">safe_zip</span><span class="p">,</span> <span class="n">safe_map</span><span class="p">,</span> <span class="n">curry</span><span class="p">,</span> <span class="n">tuple_insert</span><span class="p">,</span>
                           <span class="n">tuple_delete</span><span class="p">,</span> <span class="n">as_hashable_function</span><span class="p">,</span>
                           <span class="n">HashableFunction</span><span class="p">,</span> <span class="n">HashableWrapper</span><span class="p">,</span> <span class="n">weakref_lru_cache</span><span class="p">,</span>
                           <span class="n">partition_list</span><span class="p">,</span> <span class="n">StrictABCMeta</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">jax._src.pretty_printer</span> <span class="k">as</span> <span class="nn">pp</span>
<span class="kn">from</span> <span class="nn">jax._src.lib</span> <span class="kn">import</span> <span class="n">jax_jit</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">traceback_util</span>
<span class="kn">from</span> <span class="nn">jax._src.typing</span> <span class="kn">import</span> <span class="n">Array</span><span class="p">,</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">Shape</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">typing</span>

<span class="n">traceback_util</span><span class="o">.</span><span class="n">register_exclusion</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>

<span class="nb">zip</span><span class="p">,</span> <span class="n">unsafe_zip</span> <span class="o">=</span> <span class="n">safe_zip</span><span class="p">,</span> <span class="nb">zip</span>
<span class="nb">map</span><span class="p">,</span> <span class="n">unsafe_map</span> <span class="o">=</span> <span class="n">safe_map</span><span class="p">,</span> <span class="nb">map</span>


<span class="n">_TRACER_ERROR_NUM_TRACEBACK_FRAMES</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">DEFINE_integer</span><span class="p">(</span>
    <span class="s1">&#39;jax_tracer_error_num_traceback_frames&#39;</span><span class="p">,</span>
    <span class="n">config</span><span class="o">.</span><span class="n">int_env</span><span class="p">(</span><span class="s1">&#39;JAX_TRACER_ERROR_NUM_TRACEBACK_FRAMES&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Set the number of stack frames in JAX tracer error messages.&#39;</span>
<span class="p">)</span>


<span class="c1"># -------------------- jaxprs --------------------</span>

<span class="n">Effect</span> <span class="o">=</span> <span class="n">effects</span><span class="o">.</span><span class="n">Effect</span>
<span class="n">Effects</span> <span class="o">=</span> <span class="n">effects</span><span class="o">.</span><span class="n">Effects</span>
<span class="n">EffectTypeSet</span> <span class="o">=</span> <span class="n">effects</span><span class="o">.</span><span class="n">EffectTypeSet</span>
<span class="n">no_effects</span><span class="p">:</span> <span class="n">Effects</span> <span class="o">=</span> <span class="n">effects</span><span class="o">.</span><span class="n">no_effects</span>

<span class="k">class</span> <span class="nc">JaxprDebugInfo</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">traced_for</span><span class="p">:</span> <span class="nb">str</span>     <span class="c1"># e.g. &#39;jit&#39;, &#39;scan&#39;, etc</span>
  <span class="n">func_src_info</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># e.g. f&#39;{fun.__name__} at {filename}:{lineno}&#39;</span>
  <span class="n">arg_names</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>     <span class="c1"># e.g. (&#39;args[0]&#39;, ... )</span>
  <span class="n">result_paths</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>  <span class="c1"># e.g. (&#39;[0]&#39;, &#39;[1]&#39;, ...)</span>

<div class="viewcode-block" id="Jaxpr">
<a class="viewcode-back" href="../../../_autosummary/jax.core.Jaxpr.html#jax.extend.random.Jaxpr">[docs]</a>
<span class="k">class</span> <span class="nc">Jaxpr</span><span class="p">:</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;__weakref__&#39;</span><span class="p">,</span> <span class="s1">&#39;_constvars&#39;</span><span class="p">,</span> <span class="s1">&#39;_invars&#39;</span><span class="p">,</span> <span class="s1">&#39;_outvars&#39;</span><span class="p">,</span> <span class="s1">&#39;_eqns&#39;</span><span class="p">,</span>
               <span class="s1">&#39;_effects&#39;</span><span class="p">,</span> <span class="s1">&#39;_debug_info&#39;</span><span class="p">]</span>

  <span class="n">_constvars</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span>
  <span class="n">_invars</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span>
  <span class="n">_outvars</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span>
  <span class="n">_eqns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">]</span>
  <span class="n">_effects</span><span class="p">:</span> <span class="n">Effects</span>
  <span class="n">_debug_info</span><span class="p">:</span> <span class="n">JaxprDebugInfo</span> <span class="o">|</span> <span class="kc">None</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">constvars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Var</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constvars</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">invars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Var</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invars</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">outvars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Atom</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outvars</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">eqns</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eqns</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">effects</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Effects</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_effects</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">debug_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JaxprDebugInfo</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_info</span>

<div class="viewcode-block" id="Jaxpr.__init__">
<a class="viewcode-back" href="../../../_autosummary/jax.core.Jaxpr.html#jax.extend.random.Jaxpr.__init__">[docs]</a>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constvars</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Var</span><span class="p">],</span> <span class="n">invars</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Var</span><span class="p">],</span>
               <span class="n">outvars</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Atom</span><span class="p">],</span> <span class="n">eqns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">],</span>
               <span class="n">effects</span><span class="p">:</span> <span class="n">Effects</span> <span class="o">=</span> <span class="n">no_effects</span><span class="p">,</span>
               <span class="n">debug_info</span><span class="p">:</span> <span class="n">JaxprDebugInfo</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">      constvars: list of variables introduced for constants. Array constants are</span>
<span class="sd">        replaced with such variables while scalar constants are kept inline.</span>
<span class="sd">      invars: list of input variables. Together, `constvars` and `invars` are</span>
<span class="sd">        the inputs to the Jaxpr.</span>
<span class="sd">      outvars: list of output atoms.</span>
<span class="sd">      eqns: list of equations.</span>
<span class="sd">      effects: set of effects. The effects on a jaxpr are a superset of the</span>
<span class="sd">        union of the effects for each equation.</span>
<span class="sd">      debug_info: optional JaxprDebugInfo.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_constvars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">constvars</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_invars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">invars</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_outvars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">outvars</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_eqns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">eqns</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_effects</span> <span class="o">=</span> <span class="n">effects</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_info</span> <span class="o">=</span> <span class="n">debug_info</span>
    <span class="k">assert</span> <span class="p">(</span><span class="ow">not</span> <span class="n">debug_info</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">debug_info</span><span class="o">.</span><span class="n">arg_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">invars</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">debug_info</span><span class="o">.</span><span class="n">result_paths</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">outvars</span><span class="p">))</span></div>


  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_print</span><span class="p">())</span>

  <span class="fm">__repr__</span> <span class="o">=</span> <span class="fm">__str__</span>

  <span class="k">def</span> <span class="nf">pretty_print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">source_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">custom_pp_eqn_rules</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name_stack</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">print_effects</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">context</span> <span class="o">=</span> <span class="n">JaxprPpContext</span><span class="p">()</span>
    <span class="n">settings</span> <span class="o">=</span> <span class="n">JaxprPpSettings</span><span class="p">(</span>
        <span class="n">source_info</span><span class="o">=</span><span class="n">source_info</span><span class="p">,</span>
        <span class="n">print_shapes</span><span class="o">=</span><span class="n">print_shapes</span><span class="p">,</span>
        <span class="n">custom_pp_eqn_rules</span><span class="o">=</span><span class="n">custom_pp_eqn_rules</span><span class="p">,</span>
        <span class="n">name_stack</span><span class="o">=</span><span class="n">name_stack</span><span class="p">,</span>
        <span class="n">print_effects</span><span class="o">=</span><span class="n">print_effects</span><span class="p">)</span>

    <span class="c1"># Compute how many times each jaxpr is used.</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="nb">str</span><span class="p">](</span><span class="k">lambda</span><span class="p">:</span> <span class="s2">&quot;jaxpr&quot;</span><span class="p">)</span>
    <span class="n">jaxpr_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">]()</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">s</span><span class="p">:</span>
      <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
      <span class="n">jaxpr_counts</span><span class="p">[</span><span class="n">jaxpr</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
        <span class="c1"># TODO(slebedev): Come up with a more elaborate heuristic for name=.</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
          <span class="n">s</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">jaxprs_in_params</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">))</span>
          <span class="k">continue</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;&lt;&gt;&quot;</span><span class="p">)</span>  <span class="c1"># &lt;lambda&gt; -&gt; lambda</span>
        <span class="k">for</span> <span class="n">subjaxpr</span> <span class="ow">in</span> <span class="n">jaxprs_in_params</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">):</span>
          <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subjaxpr</span><span class="p">)</span>
          <span class="n">names</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">subjaxpr</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="c1"># Pull jaxprs occurring more than once to the top-level, making sure</span>
    <span class="c1"># that their names are unique.</span>
    <span class="n">docs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">name_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">[</span><span class="nb">str</span><span class="p">]()</span>
    <span class="k">for</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">jaxpr_counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">continue</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">jaxpr</span><span class="p">]</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">:=</span> <span class="n">name_counts</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">name_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">name</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="n">name_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">name_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">docs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp_top_level_jaxpr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">))</span>
      <span class="n">context</span><span class="o">.</span><span class="n">used_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
      <span class="n">context</span><span class="o">.</span><span class="n">top_level_jaxprs</span><span class="p">[</span><span class="n">jaxpr</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">docs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp_jaxpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">docs</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_print</span><span class="p">(</span><span class="n">use_color</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">constvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">invars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eqns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">effects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">constvars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constvars</span> <span class="k">if</span> <span class="n">constvars</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">constvars</span>
    <span class="n">invars</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">invars</span> <span class="k">if</span> <span class="n">invars</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">invars</span>
    <span class="n">outvars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outvars</span> <span class="k">if</span> <span class="n">outvars</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">outvars</span>
    <span class="n">eqns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eqns</span> <span class="k">if</span> <span class="n">eqns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">eqns</span>
    <span class="n">effects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">effects</span> <span class="k">if</span> <span class="n">effects</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">effects</span>
    <span class="n">debug_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_info</span> <span class="k">if</span> <span class="n">debug_info</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">debug_info</span>
    <span class="k">return</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">constvars</span><span class="o">=</span><span class="n">constvars</span><span class="p">,</span> <span class="n">invars</span><span class="o">=</span><span class="n">invars</span><span class="p">,</span> <span class="n">outvars</span><span class="o">=</span><span class="n">outvars</span><span class="p">,</span> <span class="n">eqns</span><span class="o">=</span><span class="n">eqns</span><span class="p">,</span>
                 <span class="n">effects</span><span class="o">=</span><span class="n">effects</span><span class="p">,</span> <span class="n">debug_info</span><span class="o">=</span><span class="n">debug_info</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">join_effects</span><span class="p">(</span><span class="o">*</span><span class="n">effects</span><span class="p">:</span> <span class="n">Effects</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Effects</span><span class="p">:</span>
  <span class="k">return</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">effects</span><span class="p">)</span> <span class="k">if</span> <span class="n">effects</span> <span class="k">else</span> <span class="n">no_effects</span>

<span class="k">def</span> <span class="nf">jaxprs_in_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">]:</span>
  <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">val</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">val</span><span class="p">,)</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">v</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">v</span><span class="o">.</span><span class="n">jaxpr</span>


<span class="k">def</span> <span class="nf">subjaxprs</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">]:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Generator for all subjaxprs found in the params of jaxpr.eqns.</span>
<span class="sd">  Does not descend recursively into the found subjaxprs.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
    <span class="k">yield from</span> <span class="n">jaxprs_in_params</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>


<div class="viewcode-block" id="ClosedJaxpr">
<a class="viewcode-back" href="../../../_autosummary/jax.core.ClosedJaxpr.html#jax.extend.random.ClosedJaxpr">[docs]</a>
<span class="k">class</span> <span class="nc">ClosedJaxpr</span><span class="p">:</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;__weakref__&#39;</span><span class="p">,</span> <span class="s1">&#39;_jaxpr&#39;</span><span class="p">,</span> <span class="s1">&#39;_consts&#39;</span><span class="p">]</span>

  <span class="n">_jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span>
  <span class="n">_consts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>

  <span class="n">jaxpr</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jaxpr</span><span class="p">)</span>
  <span class="n">consts</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_consts</span><span class="p">)</span>

<div class="viewcode-block" id="ClosedJaxpr.__init__">
<a class="viewcode-back" href="../../../_autosummary/jax.core.ClosedJaxpr.html#jax.extend.random.ClosedJaxpr.__init__">[docs]</a>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">consts</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">)</span>
    <span class="c1"># assert not any(isinstance(c, Tracer) for c in consts)  # TODO(mattjj): enable</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_jaxpr</span> <span class="o">=</span> <span class="n">jaxpr</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_consts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">consts</span><span class="p">)</span></div>


  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">in_avals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">]</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">out_avals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">]</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">literals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">consts</span>  <span class="c1"># backwards compatible alias</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">eqns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">effects</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Effects</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span>

  <span class="k">def</span> <span class="nf">map_jaxpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">consts</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">consts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">jaxpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span> <span class="k">if</span> <span class="n">jaxpr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">jaxpr</span>
    <span class="n">consts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">consts</span> <span class="k">if</span> <span class="n">consts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">consts</span>
    <span class="k">return</span> <span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">pretty_print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">source_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">name_stack</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">custom_pp_eqn_rules</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">print_effects</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">pretty_print</span><span class="p">(</span>
        <span class="n">source_info</span><span class="o">=</span><span class="n">source_info</span><span class="p">,</span>
        <span class="n">print_shapes</span><span class="o">=</span><span class="n">print_shapes</span><span class="p">,</span>
        <span class="n">name_stack</span><span class="o">=</span><span class="n">name_stack</span><span class="p">,</span>
        <span class="n">custom_pp_eqn_rules</span><span class="o">=</span><span class="n">custom_pp_eqn_rules</span><span class="p">,</span>
        <span class="n">print_effects</span><span class="o">=</span><span class="n">print_effects</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_print</span><span class="p">(</span><span class="n">use_color</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>


<span class="nd">@curry</span>
<span class="k">def</span> <span class="nf">jaxpr_as_fun</span><span class="p">(</span><span class="n">closed_jaxpr</span><span class="p">:</span> <span class="n">ClosedJaxpr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">eval_jaxpr</span><span class="p">(</span><span class="n">closed_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">closed_jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">JaxprEqn</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">invars</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span>
  <span class="n">outvars</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span>
  <span class="n">primitive</span><span class="p">:</span> <span class="n">Primitive</span>
  <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
  <span class="n">effects</span><span class="p">:</span> <span class="n">Effects</span>
  <span class="n">source_info</span><span class="p">:</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">SourceInfo</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp_eqn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">JaxprPpContext</span><span class="p">(),</span> <span class="n">JaxprPpSettings</span><span class="p">()))</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span>
      <span class="n">invars</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
      <span class="n">outvars</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
      <span class="n">primitive</span><span class="p">:</span> <span class="n">Primitive</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
      <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
      <span class="n">effects</span><span class="p">:</span> <span class="n">Effects</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
      <span class="n">source_info</span><span class="p">:</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">SourceInfo</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
  <span class="p">):</span>
    <span class="c1"># It is slightly faster to rebuild the tuple directly than to call _replace.</span>
    <span class="k">return</span> <span class="n">JaxprEqn</span><span class="p">(</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">invars</span> <span class="k">if</span> <span class="n">invars</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">invars</span><span class="p">,</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">outvars</span> <span class="k">if</span> <span class="n">outvars</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">outvars</span><span class="p">,</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">primitive</span> <span class="k">if</span> <span class="n">primitive</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">primitive</span><span class="p">,</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">params</span><span class="p">,</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">effects</span> <span class="k">if</span> <span class="n">effects</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">effects</span><span class="p">,</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">source_info</span> <span class="k">if</span> <span class="n">source_info</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">source_info</span><span class="p">,</span>
    <span class="p">)</span>


<span class="c1"># TODO(mattjj): call typecheck rules here, so we don&#39;t form bad eqns</span>
<span class="k">def</span> <span class="nf">new_jaxpr_eqn</span><span class="p">(</span><span class="n">invars</span><span class="p">,</span> <span class="n">outvars</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">effects</span><span class="p">,</span> <span class="n">source_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">source_info</span> <span class="o">=</span> <span class="n">source_info</span> <span class="ow">or</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">new_source_info</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">enable_checks</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">Var</span><span class="p">,</span> <span class="n">Literal</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>  <span class="n">invars</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span>  <span class="n">Var</span><span class="p">)</span>           <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">outvars</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">JaxprEqn</span><span class="p">(</span><span class="n">invars</span><span class="p">,</span> <span class="n">outvars</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">effects</span><span class="p">,</span> <span class="n">source_info</span><span class="p">)</span>

<span class="n">_var_counter</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">Var</span><span class="p">:</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="s2">&quot;suffix&quot;</span><span class="p">,</span> <span class="s2">&quot;aval&quot;</span><span class="p">]</span>

  <span class="n">count</span><span class="p">:</span> <span class="nb">int</span>
  <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">_var_counter</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">suffix</span> <span class="o">=</span> <span class="n">suffix</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">aval</span> <span class="o">=</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>

  <span class="c1"># TODO(phawkins, mattjj): remove ordering of variables. JAX itself does not</span>
  <span class="c1"># care about variable ordering, but the downstream package kfac_jax does.</span>
  <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">count</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Var(id=</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s1">)</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">suffix</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">str_short</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span>


<span class="k">def</span> <span class="nf">gensym</span><span class="p">(</span><span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">AbstractValue</span><span class="p">],</span> <span class="n">Var</span><span class="p">]:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Produce distinct variables, printed with the optional suffix.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">Var</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span>

<span class="c1"># In a jaxpr, `dropvar` can appear in place of a bound variable to indicate that</span>
<span class="c1"># the assignment is dropped, i.e. that an expression&#39;s output value will never</span>
<span class="c1"># be read. In that sense, `dropvar` is not a variable, but it is convenient to</span>
<span class="c1"># treat it as a special case of one. Its `aval` is similarly inexact.</span>
<span class="k">class</span> <span class="nc">DropVar</span><span class="p">(</span><span class="n">Var</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;_&#39;</span>

<span class="k">class</span> <span class="nc">Literal</span><span class="p">:</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">,</span> <span class="s2">&quot;aval&quot;</span><span class="p">,</span> <span class="s2">&quot;hash&quot;</span><span class="p">]</span>

  <span class="n">val</span><span class="p">:</span> <span class="n">Any</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span>
  <span class="nb">hash</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">aval</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">literalable_types</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="n">val</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="kc">None</span>

  <span class="fm">__hash__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">):</span>
      <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Literal(val=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s1">)&#39;</span>

<span class="n">literalable_types</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="n">Atom</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Literal</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Primitive</span><span class="p">:</span>
  <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
  <span class="c1"># set for multi-output primitives.</span>
  <span class="n">multiple_results</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="c1"># set for call primitives processed in final style.</span>
  <span class="n">call_primitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="c1"># set for map primitives processed in final style.</span>
  <span class="n">map_primitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span>

  <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="k">assert</span> <span class="p">(</span><span class="ow">not</span> <span class="n">config</span><span class="o">.</span><span class="n">enable_checks</span><span class="o">.</span><span class="n">value</span> <span class="ow">or</span>
            <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">valid_jaxtype</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)),</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind_with_trace</span><span class="p">(</span><span class="n">find_top_trace</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">args</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">bind_with_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">full_raise</span><span class="p">,</span> <span class="n">args</span><span class="p">),</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">full_lower</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiple_results</span> <span class="k">else</span> <span class="n">full_lower</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">def_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">impl</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">impl</span> <span class="o">=</span> <span class="n">impl</span>
    <span class="k">return</span> <span class="n">impl</span>

  <span class="k">def</span> <span class="nf">def_abstract_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abstract_eval</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">abstract_eval</span> <span class="o">=</span> <span class="n">_effect_free_abstract_eval</span><span class="p">(</span><span class="n">abstract_eval</span><span class="p">)</span>  <span class="c1"># type: ignore[assignment]</span>
    <span class="k">return</span> <span class="n">abstract_eval</span>

  <span class="k">def</span> <span class="nf">def_effectful_abstract_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">effectful_abstract_eval</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">abstract_eval</span> <span class="o">=</span> <span class="n">effectful_abstract_eval</span>  <span class="c1"># type: ignore[assignment]</span>
    <span class="k">return</span> <span class="n">effectful_abstract_eval</span>

  <span class="k">def</span> <span class="nf">def_custom_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bind</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">bind</span>
    <span class="k">return</span> <span class="n">bind</span>

  <span class="k">def</span> <span class="nf">impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Evaluation rule for &#39;</span><span class="si">{}</span><span class="s2">&#39; not implemented&quot;</span>
                              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">abstract_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Abstract evaluation for &#39;</span><span class="si">{}</span><span class="s2">&#39; not implemented&quot;</span>
                              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">get_bind_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[],</span> <span class="n">params</span>


<span class="k">def</span> <span class="nf">_effect_free_abstract_eval</span><span class="p">(</span><span class="n">abstract_eval</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">abstract_eval_</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">abstract_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">no_effects</span>
  <span class="k">return</span> <span class="n">abstract_eval_</span>

<span class="c1"># -------------------- lifting --------------------</span>

<span class="c1"># TODO(mattjj): replace this approach with a primitive-keyed table of rules</span>
<span class="k">def</span> <span class="nf">traverse_jaxpr_params</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Applies f to each jaxpr parameter and returns a tuple of returned values.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
          <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
          <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">(</span><span class="n">param</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">param</span><span class="p">])</span>
          <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">)}</span>


<span class="k">def</span> <span class="nf">eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">propagate_source_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">val</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Literal</span><span class="p">)</span> <span class="k">else</span> <span class="n">env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">enable_checks</span><span class="o">.</span><span class="n">value</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">config</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
      <span class="k">assert</span> <span class="n">typecheck</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

  <span class="n">env</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">,</span> <span class="n">consts</span><span class="p">)</span>
  <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="n">lu</span> <span class="o">=</span> <span class="n">last_used</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
    <span class="n">subfuns</span><span class="p">,</span> <span class="n">bind_params</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">get_bind_params</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="n">name_stack</span> <span class="o">=</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">current_name_stack</span><span class="p">()</span> <span class="o">+</span> <span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="o">.</span><span class="n">name_stack</span>
    <span class="n">traceback</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="o">.</span><span class="n">traceback</span> <span class="k">if</span> <span class="n">propagate_source_info</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">with</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">user_context</span><span class="p">(</span><span class="n">traceback</span><span class="p">,</span> <span class="n">name_stack</span><span class="o">=</span><span class="n">name_stack</span><span class="p">):</span>
      <span class="n">ans</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">subfuns</span><span class="p">,</span> <span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">),</span> <span class="o">**</span><span class="n">bind_params</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">multiple_results</span><span class="p">:</span>
      <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">write</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ans</span><span class="p">)</span>
    <span class="n">clean_up_dead_vars</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">lu</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">)</span>


<span class="c1"># -------------------- tracing --------------------</span>

<span class="n">TracerType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;TracerType&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s1">&#39;Tracer&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Trace</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">TracerType</span><span class="p">]):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;main&#39;</span><span class="p">,</span> <span class="s1">&#39;level&#39;</span><span class="p">,</span> <span class="s1">&#39;sublevel&#39;</span><span class="p">]</span>

  <span class="n">main</span><span class="p">:</span> <span class="n">MainTrace</span>
  <span class="n">level</span><span class="p">:</span> <span class="nb">int</span>
  <span class="n">sublevel</span><span class="p">:</span> <span class="n">Sublevel</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main</span><span class="p">:</span> <span class="n">MainTrace</span><span class="p">,</span> <span class="n">sublevel</span><span class="p">:</span> <span class="n">Sublevel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">main</span> <span class="o">=</span> <span class="n">main</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">main</span><span class="o">.</span><span class="n">level</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sublevel</span> <span class="o">=</span> <span class="n">sublevel</span>

  <span class="k">def</span> <span class="nf">full_raise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TracerType</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
      <span class="c1"># This check is only applied to non-Tracers, because the hasattr() is</span>
      <span class="c1"># expensive (Tracer.__getattr__) in the common case that val is a Tracer.</span>
      <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s2">&quot;dimension_as_value&quot;</span><span class="p">):</span>  <span class="c1"># Used for shape_poly._DimExpr</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">dimension_as_value</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pure</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pure</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">val</span><span class="o">.</span><span class="n">_assert_live</span><span class="p">()</span>
    <span class="n">level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span>
    <span class="n">sublevel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sublevel</span>
    <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">main</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">sublevel</span> <span class="o">==</span> <span class="n">sublevel</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">TracerType</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">sublevel</span> <span class="o">&lt;</span> <span class="n">sublevel</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sublift</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">escaped_tracer_error</span><span class="p">(</span>
            <span class="n">val</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Can&#39;t lift sublevels </span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">sublevel</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">sublevel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">sublevel</span> <span class="o">&gt;</span> <span class="n">sublevel</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">escaped_tracer_error</span><span class="p">(</span>
            <span class="n">val</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Incompatible sublevel: </span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="p">(</span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="n">sublevel</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lift</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">:</span>
      <span class="k">raise</span> <span class="n">escaped_tracer_error</span><span class="p">(</span>
          <span class="n">val</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Can&#39;t lift level </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># val._trace.level == self.level:</span>
      <span class="k">raise</span> <span class="n">escaped_tracer_error</span><span class="p">(</span>
          <span class="n">val</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Different traces at same level: </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">pure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TracerType</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">lift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TracerType</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">sublift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TracerType</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(level=</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sublevel</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_primitive</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> must override process_call to handle call-like &quot;</span>
           <span class="s2">&quot;primitives&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_primitive</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> must override process_map to handle map-like &quot;</span>
           <span class="s2">&quot;primitives&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_custom_jvp_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">jvp</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                              <span class="n">symbolic_zeros</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> must override process_custom_jvp_call &quot;</span>
           <span class="s2">&quot;to handle custom_jvp primitives&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_custom_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> must override process_custom_transpose &quot;</span>
           <span class="s2">&quot;to handle custom_transpose_call primitives&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_custom_vjp_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">fwd</span><span class="p">,</span> <span class="n">bwd</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span>
                              <span class="n">out_trees</span><span class="p">,</span> <span class="n">symbolic_zeros</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> must override process_custom_vjp_call &quot;</span>
           <span class="s2">&quot;to handle custom_vjp primitives&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">raise_as_much_as_possible</span><span class="p">(</span><span class="n">tracer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tracer</span><span class="p">:</span>
  <span class="c1"># Find effective bottom of trace stack (highest dynamic Trace on the stack).</span>
  <span class="n">trace_stack</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">stack</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trace_stack</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span>
             <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">)</span>

  <span class="c1"># Only pay attention to effective part of trace stack.</span>
  <span class="n">trace_stack</span> <span class="o">=</span> <span class="n">trace_stack</span><span class="p">[</span><span class="n">idx</span><span class="p">:]</span>

  <span class="c1"># Lift tracer into everything in the effective stack higher than its level</span>
  <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">trace_stack</span><span class="p">:</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">with_cur_sublevel</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tracer</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">trace</span><span class="o">.</span><span class="n">level</span><span class="p">):</span>
      <span class="n">tracer</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">full_raise</span><span class="p">(</span><span class="n">tracer</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">tracer</span>


<span class="k">def</span> <span class="nf">escaped_tracer_error</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="n">detail</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">num_frames</span> <span class="o">=</span> <span class="n">_TRACER_ERROR_NUM_TRACEBACK_FRAMES</span><span class="o">.</span><span class="n">value</span>
  <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Encountered an unexpected tracer. A function transformed by JAX &#39;</span>
         <span class="s1">&#39;had a side effect, allowing for a reference to an intermediate value &#39;</span>
         <span class="sa">f</span><span class="s1">&#39;with type </span><span class="si">{</span><span class="n">tracer</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">str_short</span><span class="p">()</span><span class="si">}</span><span class="s1"> wrapped in a &#39;</span>
         <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tracer</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> to escape the scope of the transformation.</span><span class="se">\n</span><span class="s1">&#39;</span>
         <span class="s1">&#39;JAX transformations require that functions explicitly return their &#39;</span>
         <span class="s1">&#39;outputs, and disallow saving intermediate values to global state.&#39;</span><span class="p">)</span>
  <span class="n">dbg</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="s1">&#39;_debug_info&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dbg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">The function being traced when the value leaked was &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dbg</span><span class="o">.</span><span class="n">func_src_info</span><span class="si">}</span><span class="s1"> traced for </span><span class="si">{</span><span class="n">dbg</span><span class="o">.</span><span class="n">traced_for</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
  <span class="n">line_info</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="s1">&#39;_line_info&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">line_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">divider</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">30</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="n">divider</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;The leaked intermediate value was created on line &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">source_info_util</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">line_info</span><span class="p">)</span><span class="si">}</span><span class="s1">. &#39;</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="n">divider</span>
    <span class="k">if</span> <span class="n">num_frames</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;When the value was created, the final </span><span class="si">{</span><span class="n">num_frames</span><span class="si">}</span><span class="s1"> stack &#39;</span>
              <span class="s1">&#39;frames (most recent last) excluding JAX-internal frames were:&#39;</span><span class="p">)</span>
      <span class="n">msg</span> <span class="o">+=</span> <span class="n">divider</span> <span class="o">+</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span>
          <span class="n">line_info</span><span class="p">,</span> <span class="n">num_frames</span><span class="o">=</span><span class="n">num_frames</span><span class="p">)</span> <span class="o">+</span> <span class="n">divider</span>
  <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">To catch the leak earlier, try setting the environment variable &#39;</span>
          <span class="s1">&#39;JAX_CHECK_TRACER_LEAKS or using the `jax.checking_leaks` context &#39;</span>
          <span class="s1">&#39;manager.&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">detail</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;Detail: </span><span class="si">{</span><span class="n">detail</span><span class="si">}</span><span class="s1">&#39;</span>
  <span class="k">return</span> <span class="n">UnexpectedTracerError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">check_scalar_conversion</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">Array</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only scalar arrays can be converted to Python scalars; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">check_integer_conversion</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">Array</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only integer scalar arrays can be converted to a scalar index.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">check_bool_conversion</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">Array</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The truth value of an empty array is ambiguous. Use&quot;</span>
                     <span class="s2">&quot; `array.size &gt; 0` to check that an array is not empty.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The truth value of an array with more than one element&quot;</span>
                     <span class="s2">&quot; is ambiguous. Use a.any() or a.all()&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_aval_property</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Tracer</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">StrictABCMeta</span><span class="p">):</span>
  <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">1000</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_trace&#39;</span><span class="p">,</span> <span class="s1">&#39;_line_info&#39;</span><span class="p">]</span>

  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_aval_property</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">)</span>
  <span class="n">ndim</span> <span class="o">=</span> <span class="n">_aval_property</span><span class="p">(</span><span class="s1">&#39;ndim&#39;</span><span class="p">)</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">_aval_property</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">_aval_property</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">:</span> <span class="n">Trace</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>

  <span class="k">def</span> <span class="nf">_error_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;traced array with aval </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;traced array with shape </span><span class="si">{</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span><span class="o">.</span><span class="n">str_short</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>

  <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">TracerArrayConversionError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__dlpack__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The __dlpack__() method was called on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The tolist() method was called on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">tobytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
    <span class="k">del</span> <span class="n">order</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The tobytes() method was called on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

  <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

  <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">sharding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># This attribute is part of the jax.Array API, but only defined on concrete arrays.</span>
    <span class="c1"># Raising a ConcretizationTypeError would make sense, but for backward compatibility</span>
    <span class="c1"># we raise an AttributeError so that hasattr() and getattr() work as expected.</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">orig_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span>
    <span class="k">except</span><span class="p">:</span>
      <span class="n">orig_msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The &#39;sharding&#39; attribute is not available on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">orig_msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">addressable_shards</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The &#39;addressable_shards&#39; attribute is not available on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">at</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">aval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">_assert_live</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">pass</span>  <span class="c1"># Override for liveness checking</span>

  <span class="k">def</span> <span class="nf">get_referent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># Override for object equivalence checking</span>

  <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">check_bool_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">check_scalar_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_int</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">check_scalar_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_float</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">check_scalar_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__hex__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">check_integer_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_hex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__oct__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">check_integer_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_oct</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__index__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">check_integer_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="c1"># raises a useful error on attempts to pickle a Tracer.</span>
  <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;The error occurred in the __reduce__ method, which may &quot;</span>
             <span class="s2">&quot;indicate an attempt to serialize/pickle a traced value.&quot;</span><span class="p">))</span>

  <span class="c1"># raises the better error message from ShapedArray</span>
  <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_setitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

  <span class="c1"># NumPy also only looks up special methods on classes.</span>
  <span class="k">def</span> <span class="nf">__array_module__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_array_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="c1"># if the aval property raises an AttributeError, gets caught here</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">config</span><span class="o">.</span><span class="n">enable_checks</span><span class="o">.</span><span class="n">value</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;aval&quot;</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
          <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> has no attribute </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
      <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">aval_property</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">aval_method</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">fun</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attr</span>

  <span class="k">def</span> <span class="nf">_pretty_print</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Traced&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="si">}</span><span class="s1">&gt;with&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_trace</span><span class="si">}</span><span class="s1">&gt;&#39;</span><span class="p">)</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">_pretty_print</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span>
                 <span class="k">else</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">attr</span><span class="p">)))</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contents</span><span class="p">()]</span>
    <span class="k">if</span> <span class="n">contents</span><span class="p">:</span>
      <span class="n">base</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
        <span class="n">base</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39; with&#39;</span><span class="p">),</span> <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span> <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span> <span class="p">[</span>
          <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> = &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp_payload</span>
          <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">pp_payload</span> <span class="ow">in</span> <span class="n">contents</span><span class="p">])</span>
      <span class="p">])))</span>
    <span class="k">return</span> <span class="n">base</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pretty_print</span><span class="p">()</span><span class="o">.</span><span class="n">format</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">_contents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">()</span>

  <span class="k">def</span> <span class="nf">_origin_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

  <span class="c1"># Methods that are only valid for materialized arrays</span>
  <span class="k">def</span> <span class="nf">addressable_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The addressable_data() method was called on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">block_until_ready</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Raise AttributeError for backward compatibility with hasattr() and getattr() checks.</span>
    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The &#39;block_until_ready&#39; method is not available on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">copy_to_host_async</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Raise AttributeError for backward compatibility with hasattr() and getattr() checks.</span>
    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The &#39;copy_to_host_async&#39; method is not available on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The delete() method was called on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">devices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The devices() method was called on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">global_shards</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The global_shards property was called on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">is_deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The is_deleted() method was called on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">is_fully_addressable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The is_fully_addressable property was called on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">is_fully_replicated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The is_fully_replicated property was called on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">on_device_size_in_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The on_device_size_in_bytes() method was called on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">traceback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The traceback property was called on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">unsafe_buffer_pointer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The unsafe_buffer_pointer() method was called on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># these can be used to set up forwarding of properties and instance methods from</span>
<span class="c1"># Tracer instances to the underlying avals</span>
<span class="n">aval_property</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;aval_property&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;fget&quot;</span><span class="p">])</span>
<span class="n">aval_method</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;aval_method&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;fun&quot;</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">EvalTrace</span><span class="p">(</span><span class="n">Trace</span><span class="p">):</span>
  <span class="c1"># See comments in https://github.com/google/jax/pull/3370</span>
  <span class="k">def</span> <span class="nf">pure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span>
  <span class="n">lift</span> <span class="o">=</span> <span class="n">sublift</span> <span class="o">=</span> <span class="n">pure</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">debug_key_reuse</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
      <span class="c1"># Import here to avoid circular imports</span>
      <span class="kn">from</span> <span class="nn">jax.experimental.key_reuse._core</span> <span class="kn">import</span> <span class="n">call_impl_with_key_reuse_checks</span>  <span class="c1"># pytype: disable=import-error</span>
      <span class="k">return</span> <span class="n">call_impl_with_key_reuse_checks</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">primitive</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span> <span class="o">*</span><span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">primitive</span><span class="o">.</span><span class="n">impl</span><span class="p">(</span><span class="o">*</span><span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">debug_key_reuse</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
      <span class="c1"># Import here to avoid circular imports</span>
      <span class="kn">from</span> <span class="nn">jax.experimental.key_reuse._core</span> <span class="kn">import</span> <span class="n">call_impl_with_key_reuse_checks</span>  <span class="c1"># pytype: disable=import-error</span>
      <span class="k">return</span> <span class="n">call_impl_with_key_reuse_checks</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">primitive</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">primitive</span><span class="o">.</span><span class="n">impl</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
  <span class="n">process_map</span> <span class="o">=</span> <span class="n">process_call</span>

  <span class="k">def</span> <span class="nf">process_custom_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
    <span class="k">del</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">_</span>
    <span class="k">with</span> <span class="n">new_sublevel</span><span class="p">():</span>
      <span class="k">return</span> <span class="n">call</span><span class="o">.</span><span class="n">call_wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">tracers</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_custom_jvp_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">jvp</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
    <span class="k">del</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">jvp</span><span class="p">,</span> <span class="n">_</span>  <span class="c1"># Unused.</span>
    <span class="k">with</span> <span class="n">new_sublevel</span><span class="p">():</span>
      <span class="k">return</span> <span class="n">fun</span><span class="o">.</span><span class="n">call_wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">tracers</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_custom_vjp_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">fwd</span><span class="p">,</span> <span class="n">bwd</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>  <span class="c1"># pytype: disable=signature-mismatch</span>
    <span class="k">del</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">fwd</span><span class="p">,</span> <span class="n">bwd</span><span class="p">,</span> <span class="n">_</span>  <span class="c1"># Unused.</span>
    <span class="k">with</span> <span class="n">new_sublevel</span><span class="p">():</span>
      <span class="k">return</span> <span class="n">fun</span><span class="o">.</span><span class="n">call_wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">tracers</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MainTrace</span><span class="p">:</span>
  <span class="n">level</span><span class="p">:</span> <span class="nb">int</span>
  <span class="n">trace_type</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">Trace</span><span class="p">]</span>
  <span class="n">payload</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">trace_type</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">trace_type</span> <span class="o">=</span> <span class="n">trace_type</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">payload</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;MainTrace(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">trace_type</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">)&quot;</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_type</span><span class="p">))</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MainTrace</span><span class="p">)</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">trace_type</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">payload</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">payload</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">with_cur_sublevel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_sublevel</span><span class="p">(),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">payload</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TraceStack</span><span class="p">:</span>
  <span class="c1"># See comments in https://github.com/google/jax/pull/3370</span>
  <span class="n">stack</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">MainTrace</span><span class="p">]</span>
  <span class="n">dynamic</span><span class="p">:</span> <span class="n">MainTrace</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">eval_trace</span> <span class="o">=</span> <span class="n">MainTrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EvalTrace</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">eval_trace</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="n">eval_trace</span>

  <span class="k">def</span> <span class="nf">next_level</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main_trace</span><span class="p">:</span> <span class="n">MainTrace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">main_trace</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">stack_str</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Trace stack</span><span class="se">\n</span><span class="si">{</span><span class="n">stack_str</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span><span class="si">}</span><span class="s1">&#39;</span>

  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">TraceStack</span><span class="p">)</span>
    <span class="n">new</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[:]</span>
    <span class="n">new</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span>
    <span class="k">return</span> <span class="n">new</span>


<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">Sublevel</span><span class="p">:</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Sublevel</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span>

  <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Sublevel</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span>


<span class="n">AxisEnvFrame</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;AxisEnvFrame&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39;main_trace&#39;</span><span class="p">])</span>
<span class="n">AxisName</span> <span class="o">=</span> <span class="n">Hashable</span>

<span class="n">no_axis_name</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">TraceState</span><span class="p">:</span>
  <span class="n">trace_stack</span><span class="p">:</span> <span class="n">TraceStack</span>
  <span class="n">substack</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Sublevel</span><span class="p">]</span>
  <span class="n">axis_env</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">AxisEnvFrame</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">trace_stack</span> <span class="o">=</span> <span class="n">TraceStack</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">substack</span> <span class="o">=</span> <span class="p">[</span><span class="n">Sublevel</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">axis_env</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">TraceState</span><span class="p">)</span>
    <span class="n">new</span><span class="o">.</span><span class="n">trace_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new</span><span class="o">.</span><span class="n">substack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substack</span><span class="p">[:]</span>
    <span class="n">new</span><span class="o">.</span><span class="n">axis_env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_env</span><span class="p">[:]</span>
    <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span> <span class="nf">_update_thread_local_jit_state</span><span class="p">(</span><span class="n">dynamic</span><span class="p">):</span>
  <span class="c1"># Copies the MainTrace instance, removing any .debug_info or .jaxpr_stack</span>
  <span class="c1"># fields that should not be kept alive as part of a cache key.</span>
  <span class="c1"># TODO(mattjj): split debug_info and jaxpr_stack out of MainTrace.</span>
  <span class="c1"># TODO(mattjj): add a test that verifies that JIT-ted functions are not kept</span>
  <span class="c1"># alive by the JIT cache, particularly for nested JIT-ted functions.</span>
  <span class="n">copy</span> <span class="o">=</span> <span class="n">MainTrace</span><span class="p">(</span><span class="n">dynamic</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">.</span><span class="n">trace_type</span><span class="p">,</span> <span class="o">**</span><span class="n">dynamic</span><span class="o">.</span><span class="n">payload</span><span class="p">)</span>
  <span class="n">config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span><span class="n">dynamic_trace_state</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>


<span class="c1"># The global state of the tracer is accessed by a thread-local object.</span>
<span class="c1"># This allows concurrent tracing in separate threads; passing traced objects</span>
<span class="c1"># between threads is forbidden.</span>
<span class="k">class</span> <span class="nc">ThreadLocalState</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">trace_state</span> <span class="o">=</span> <span class="n">TraceState</span><span class="p">()</span>

<span class="n">thread_local_state</span> <span class="o">=</span> <span class="n">ThreadLocalState</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_initialize_jax_jit_thread_local_state</span><span class="p">():</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Initializes the C++ thread-local context.</span>

<span class="sd">  When the user spawns threads, the C++ `jax_jit.thread_local_state` is None.</span>
<span class="sd">  The C++ accessor calls this function if it realizes the thread_local_state</span>
<span class="sd">  is None (which means it&#39;s not yet initialized for this thread).</span>

<span class="sd">  This function does not live in `config.py`, to prevent circular imports.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">tls</span> <span class="o">=</span> <span class="n">jax_jit</span><span class="o">.</span><span class="n">thread_local_state</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">tls</span><span class="o">.</span><span class="n">extra_jit_context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dynamic</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">dynamic</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">MainTrace</span><span class="p">(</span><span class="n">dynamic</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">.</span><span class="n">trace_type</span><span class="p">,</span> <span class="o">**</span><span class="n">dynamic</span><span class="o">.</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span><span class="n">dynamic_trace_state</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>


<span class="n">jax_jit</span><span class="o">.</span><span class="n">set_thread_local_state_initialization_callback</span><span class="p">(</span>
    <span class="n">_initialize_jax_jit_thread_local_state</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">trace_state_clean</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="n">trace_state</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">trace_state</span><span class="o">.</span><span class="n">substack</span> <span class="o">==</span> <span class="p">[</span><span class="n">Sublevel</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> <span class="ow">and</span>
          <span class="n">trace_state</span><span class="o">.</span><span class="n">axis_env</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">and</span>
          <span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">stack</span> <span class="o">==</span> <span class="p">[</span><span class="n">MainTrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EvalTrace</span><span class="p">)]</span> <span class="ow">and</span>
          <span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">==</span> <span class="n">MainTrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EvalTrace</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">reset_trace_state</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Resets the global trace state and returns True if it was already clean.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">trace_state_clean</span><span class="p">():</span>
    <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>  <span class="c1"># type: ignore</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">cur_sublevel</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Sublevel</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">substack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">TRACER_LEAK_DEBUGGER_WARNING</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">JAX check_tracer_leaks behavior can trigger false positives when used with a debugger.</span>
<span class="s2">To avoid false positives and silence this warning, you can disable thread tracing using</span>
<span class="s2">the following:</span>

<span class="s2">  import threading</span>
<span class="s2">  threading.current_thread().pydev_do_not_trace = True</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">maybe_find_leaked_tracers</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">MainTrace</span> <span class="o">|</span> <span class="n">Sublevel</span> <span class="o">|</span> <span class="kc">None</span>
                              <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Tracer</span><span class="p">]:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Find the leaked tracers holding a reference to the MainTrace or SubLevel.</span>

<span class="sd">  It&#39;s possible there&#39;s none! eg. there&#39;s some cases where JAX itself holds a</span>
<span class="sd">  reference to `x` inside of a lambda closure, and no tracers were leaked</span>
<span class="sd">  by the user. In this case an empty list is returned.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">(),</span> <span class="s1">&#39;pydev_do_not_trace&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">TRACER_LEAK_DEBUGGER_WARNING</span><span class="p">)</span>
  <span class="c1"># Trigger garbage collection to filter out unreachable objects that are alive</span>
  <span class="c1"># only due to cyclical dependencies. (We don&#39;t care about unreachable leaked</span>
  <span class="c1"># tracers since they can&#39;t interact with user code and cause a problem.)</span>
  <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
  <span class="n">traces</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Trace</span><span class="p">),</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_referrers</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
  <span class="n">tracers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">),</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_referrers</span><span class="p">(</span><span class="o">*</span><span class="n">traces</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">tracers</span>

<span class="k">def</span> <span class="nf">leaked_tracer_error</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">tracers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Tracer</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="ne">Exception</span><span class="p">:</span>
  <span class="k">assert</span> <span class="n">tracers</span>
  <span class="n">why</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_why_alive</span><span class="p">,</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">tracers</span><span class="p">)})</span>
  <span class="n">msgs</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tracers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}{</span><span class="n">tracers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}{</span><span class="n">why</span><span class="p">(</span><span class="n">tracers</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span>
                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tracers</span><span class="p">)))</span>
  <span class="k">return</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Leaked </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">. Leaked tracer(s):</span><span class="se">\n\n</span><span class="si">{</span><span class="n">msgs</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_why_alive</span><span class="p">(</span><span class="n">ignore_ids</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="n">parents</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_referrers</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignore_ids</span><span class="p">]</span>
  <span class="n">child</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">seen</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="p">[],</span> <span class="nb">set</span><span class="p">()</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span>
         <span class="ow">and</span> <span class="n">parents</span><span class="p">(</span><span class="n">child</span><span class="p">)):</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">parents</span><span class="p">(</span><span class="n">child</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># just pick one parent</span>

    <span class="c1"># For namespaces (like modules and class instances) and closures, the</span>
    <span class="c1"># references may form a simple chain: e.g. instance refers to its own</span>
    <span class="c1"># __dict__ which refers to child, or function refers to its __closure__</span>
    <span class="c1"># which refers to cells which refer to child. In these cases, we can provide</span>
    <span class="c1"># a more intuitive description by collapsing the chain into a single</span>
    <span class="c1"># parent-&gt;child jump. We do that by setting `parent` here to be a</span>
    <span class="c1"># grandparent (or great-grandparent) of `child`, and then handling that case</span>
    <span class="c1"># in _why_alive_container_info. See example:</span>
    <span class="c1">#  https://github.com/google/jax/pull/13022#discussion_r1008456599</span>
    <span class="c1"># To prevent this collapsing behavior, just comment out this code block.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">parents</span><span class="p">(</span><span class="n">parent</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="n">parents</span><span class="p">(</span><span class="n">child</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
      <span class="n">parent</span> <span class="o">=</span> <span class="n">parents</span><span class="p">(</span><span class="n">parent</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="ow">is</span> <span class="n">types</span><span class="o">.</span><span class="n">CellType</span><span class="p">:</span>
      <span class="n">parent</span> <span class="o">=</span> <span class="n">parents</span><span class="p">(</span><span class="n">parents</span><span class="p">(</span><span class="n">parent</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">line</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&lt;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="si">}</span><span class="s1">&gt; is referred to by &#39;</span>
    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="n">_why_alive_container_info</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">child</span><span class="p">)))</span>
    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
    <span class="n">child</span> <span class="o">=</span> <span class="n">parent</span>
  <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">if</span> <span class="n">lines</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

<span class="k">def</span> <span class="nf">_why_alive_container_info</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">obj_id</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&lt;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">container</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">container</span><span class="p">)</span><span class="si">}</span><span class="s1">&gt;&#39;</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">container</span><span class="p">)</span> <span class="ow">is</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">:</span>
    <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">container</span><span class="p">)</span> <span class="ow">is</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">:</span>
    <span class="n">name_</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;no-name&gt;&#39;</span><span class="p">)</span>
    <span class="n">closure</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getclosurevars</span><span class="p">(</span><span class="n">container</span><span class="p">)</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">closure</span><span class="o">.</span><span class="n">nonlocals</span><span class="p">,</span> <span class="o">**</span><span class="n">closure</span><span class="o">.</span><span class="n">globals</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">obj_id</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">name_</span><span class="si">}</span><span class="s1">) closed-over variable </span><span class="si">{</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> in closed-over variables &#39;</span> <span class="o">+</span>
                                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="n">keys</span><span class="p">)))</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">):</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">container</span><span class="p">)</span> <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="n">container</span><span class="p">)[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="n">obj_id</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> in vars &#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="n">keys</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">container</span><span class="p">)</span> <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">obj_id</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">]&#39;</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> at indices &#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">idxs</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">container</span> <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">container</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="n">obj_id</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">!r}</span><span class="s1">]&#39;</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> at keys &#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="n">keys</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39; named </span><span class="si">{</span><span class="n">container</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span>
  <span class="k">return</span> <span class="n">name</span>


<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">new_main</span><span class="p">(</span><span class="n">trace_type</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">Trace</span><span class="p">],</span> <span class="n">dynamic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
             <span class="o">**</span><span class="n">payload</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">MainTrace</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
  <span class="c1"># See comments in https://github.com/google/jax/pull/3370</span>
  <span class="n">stack</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span>
  <span class="n">level</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">next_level</span><span class="p">()</span>
  <span class="n">main</span> <span class="o">=</span> <span class="n">MainTrace</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">trace_type</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dynamic</span><span class="p">:</span>
    <span class="n">prev_dynamic</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">,</span> <span class="n">main</span>
    <span class="n">_update_thread_local_jit_state</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span> <span class="n">main</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">dynamic</span><span class="p">:</span>
      <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="n">prev_dynamic</span>
      <span class="n">_update_thread_local_jit_state</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">check_tracer_leaks</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">main</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">leaked_tracers</span> <span class="o">=</span> <span class="n">maybe_find_leaked_tracers</span><span class="p">(</span><span class="n">t</span><span class="p">())</span>
      <span class="k">if</span> <span class="n">leaked_tracers</span><span class="p">:</span> <span class="k">raise</span> <span class="n">leaked_tracer_error</span><span class="p">(</span><span class="s2">&quot;trace&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">(),</span> <span class="n">leaked_tracers</span><span class="p">)</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">new_dynamic</span><span class="p">(</span><span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
  <span class="n">stack</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span>
  <span class="n">prev_dynamic</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
  <span class="n">_update_thread_local_jit_state</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="n">prev_dynamic</span>
    <span class="n">_update_thread_local_jit_state</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dynamic_level</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">dynamic</span><span class="o">.</span><span class="n">level</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">new_base_main</span><span class="p">(</span><span class="n">trace_type</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">Trace</span><span class="p">],</span>
                  <span class="o">**</span><span class="n">payload</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">MainTrace</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
  <span class="c1"># See comments in https://github.com/google/jax/pull/3370</span>
  <span class="n">stack</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span>
  <span class="n">main</span> <span class="o">=</span> <span class="n">MainTrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace_type</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="n">prev_dynamic</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">,</span> <span class="n">main</span>
  <span class="n">prev_base</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">main</span>
  <span class="n">_update_thread_local_jit_state</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span> <span class="n">main</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="n">prev_dynamic</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_base</span>
    <span class="n">_update_thread_local_jit_state</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">check_tracer_leaks</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">main</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">leaked_tracers</span> <span class="o">=</span> <span class="n">maybe_find_leaked_tracers</span><span class="p">(</span><span class="n">t</span><span class="p">())</span>
      <span class="k">if</span> <span class="n">leaked_tracers</span><span class="p">:</span> <span class="k">raise</span> <span class="n">leaked_tracer_error</span><span class="p">(</span><span class="s2">&quot;trace&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">(),</span> <span class="n">leaked_tracers</span><span class="p">)</span>

<div class="viewcode-block" id="ensure_compile_time_eval">
<a class="viewcode-back" href="../../../_autosummary/jax.ensure_compile_time_eval.html#jax.extend.random.ensure_compile_time_eval">[docs]</a>
<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">ensure_compile_time_eval</span><span class="p">():</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Context manager to ensure evaluation at trace/compile time (or error).</span>

<span class="sd">  Some JAX APIs like :func:`jax.jit` and :func:`jax.lax.scan` involve staging,</span>
<span class="sd">  i.e., delaying the evaluation of numerical expressions (like :mod:`jax.numpy`</span>
<span class="sd">  function applications) so that instead of performing those computations</span>
<span class="sd">  eagerly while evaluating the corresponding Python expressions, their</span>
<span class="sd">  computation is carried out separately, e.g. after optimized compilation. But</span>
<span class="sd">  this delay can be undesirable. For example, numerical values might be needed</span>
<span class="sd">  to evaluate Python control flow and so their evaluation cannot be delayed. As</span>
<span class="sd">  another example, it may be beneficial to ensure compile time evaluation (or</span>
<span class="sd">  &quot;constant folding&quot;) for performance reasons.</span>

<span class="sd">  This context manager ensures that JAX computations are evaluated eagerly. If</span>
<span class="sd">  eager evaluation is not possible, a ``ConcretizationTypeError`` is raised.</span>

<span class="sd">  Here&#39;s a contrived example::</span>

<span class="sd">    import jax</span>
<span class="sd">    import jax.numpy as jnp</span>

<span class="sd">    @jax.jit</span>
<span class="sd">    def f(x):</span>
<span class="sd">      with jax.ensure_compile_time_eval():</span>
<span class="sd">        y = jnp.sin(3.0)</span>
<span class="sd">        z = jnp.sin(y)</span>
<span class="sd">        z_positive = z &gt; 0</span>
<span class="sd">      if z_positive:  # z_positive is usable in Python control flow</span>
<span class="sd">        return jnp.sin(x)</span>
<span class="sd">      else:</span>
<span class="sd">        return jnp.cos(x)</span>

<span class="sd">  Here&#39;s a real-world example from https://github.com/google/jax/issues/3974::</span>

<span class="sd">    import jax</span>
<span class="sd">    import jax.numpy as jnp</span>
<span class="sd">    from jax import random</span>

<span class="sd">    @jax.jit</span>
<span class="sd">    def jax_fn(x):</span>
<span class="sd">      with jax.ensure_compile_time_eval():</span>
<span class="sd">        y = random.randint(random.key(0), (1000,1000), 0, 100)</span>
<span class="sd">      y2 = y @ y</span>
<span class="sd">      x2 = jnp.sum(y2) * x</span>
<span class="sd">      return x2</span>

<span class="sd">  A similar behavior can often be achieved simply by &#39;hoisting&#39; the constant</span>
<span class="sd">  expression out of the corresponding staging API::</span>

<span class="sd">    y = random.randint(random.key(0), (1000,1000), 0, 100)</span>

<span class="sd">    @jax.jit</span>
<span class="sd">    def jax_fn(x):</span>
<span class="sd">      y2 = y @ y</span>
<span class="sd">      x2 = jnp.sum(y2)*x</span>
<span class="sd">      return x2</span>

<span class="sd">  But in some cases it can be more convenient to use this context manager.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">with</span> <span class="n">new_base_main</span><span class="p">(</span><span class="n">EvalTrace</span><span class="p">):</span>
    <span class="k">yield</span></div>

<span class="n">eval_context</span> <span class="o">=</span> <span class="n">ensure_compile_time_eval</span>  <span class="c1"># alias, backward compatibility</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">new_sublevel</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
  <span class="n">sublevel</span> <span class="o">=</span> <span class="n">Sublevel</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">substack</span><span class="p">))</span>
  <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">substack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sublevel</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">substack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">check_tracer_leaks</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">sublevel</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">sublevel</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">leaked_tracers</span> <span class="o">=</span> <span class="n">maybe_find_leaked_tracers</span><span class="p">(</span><span class="n">t</span><span class="p">())</span>
      <span class="k">if</span> <span class="n">leaked_tracers</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">leaked_tracer_error</span><span class="p">(</span><span class="s2">&quot;sublevel&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">(),</span> <span class="n">leaked_tracers</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">full_lower</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">full_lower</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">_get_trace_level</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Tracer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">level</span>


<span class="k">def</span> <span class="nf">find_top_trace</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Trace</span><span class="p">:</span>
  <span class="n">top_tracer</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)),</span>
                    <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">_get_trace_level</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">top_tracer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">top_tracer</span><span class="o">.</span><span class="n">_assert_live</span><span class="p">()</span>
    <span class="n">top_main</span> <span class="o">=</span> <span class="n">top_tracer</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">top_main</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>
  <span class="n">dynamic</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">dynamic</span>
  <span class="n">top_main</span> <span class="o">=</span> <span class="p">(</span><span class="n">dynamic</span> <span class="k">if</span> <span class="n">top_main</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dynamic</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">top_main</span><span class="o">.</span><span class="n">level</span>
              <span class="k">else</span> <span class="n">top_main</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">top_main</span><span class="o">.</span><span class="n">with_cur_sublevel</span><span class="p">()</span>  <span class="c1"># type: ignore</span>

<span class="k">def</span> <span class="nf">get_referent</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">get_referent</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">same_referent</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">get_referent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">get_referent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dedup_referents</span><span class="p">(</span><span class="n">itr</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
  <span class="k">return</span> <span class="nb">list</span><span class="p">({</span><span class="n">HashableWrapper</span><span class="p">(</span><span class="n">get_referent</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itr</span><span class="p">}</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">definitely_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">same_referent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">y</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">True</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
  <span class="k">except</span> <span class="n">InconclusiveDimensionOperation</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="c1"># -------------------- abstract values --------------------</span>

<span class="k">class</span> <span class="nc">AbstractValue</span><span class="p">:</span>
  <span class="vm">__slots__</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">at_least_vspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">kv_pairs</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
      <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">kv_pairs</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

  <span class="k">def</span> <span class="nf">strip_weak_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span>

  <span class="k">def</span> <span class="nf">strip_named_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span>

  <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short_dtypes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="c1"># For type signatures involving dynamic shapes, we use lists of abstract values</span>
<span class="c1"># which may contain (reverse) de Bruijn indices in their shapes.</span>
<span class="k">class</span> <span class="nc">DBIdx</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">val</span><span class="p">:</span> <span class="nb">int</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">InDBIdx</span><span class="p">:</span>
  <span class="n">val</span><span class="p">:</span> <span class="nb">int</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">OutDBIdx</span><span class="p">:</span>
  <span class="n">val</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># For annotating input types of callables (i.e. linear_util.WrappedFuns), we use</span>
<span class="c1"># a sequence of pairs where the first element of each pair is an AbstractValue</span>
<span class="c1"># (possibly containing DBIdx instances in its shape) and the second is a boolean</span>
<span class="c1"># indicating whether that argument is explicit (i.e. passed to the callable).</span>
<span class="n">InputType</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">AbstractValue</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>  <span class="c1"># DBIdx in shapes</span>

<span class="c1"># For annotating jaxpr output types, we use a sequence of pairs where the first</span>
<span class="c1"># element of each pair is an AbstractValue (possibly containing InDBIdx and/or</span>
<span class="c1"># OutDBIdx instances in its shape) and the second is a boolean indicating</span>
<span class="c1"># whether that argument is explicit (i.e. returned by the callable).</span>
<span class="n">OutputType</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">AbstractValue</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>  <span class="c1"># InDBIdx / OutDBIdx shapes</span>


<span class="k">def</span> <span class="nf">_jaxpr_type_to_callable_annotation</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InputType</span><span class="p">:</span>
  <span class="n">idxs</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">DBIdx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="o">*</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">,</span> <span class="o">*</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">))}</span>
  <span class="n">out</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idxs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
          <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="ow">is</span> <span class="n">DShapedArray</span> <span class="k">else</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">]</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bot</span><span class="p">(</span><span class="n">AbstractValue</span><span class="p">):</span> <span class="k">pass</span>
<span class="n">bot</span> <span class="o">=</span> <span class="n">Bot</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">lattice_join</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">AbstractValue</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">y</span><span class="p">:</span> <span class="n">AbstractValue</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">AbstractValue</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">AbstractValue</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
    <span class="k">return</span> <span class="n">y</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">DShapedArray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">):</span>
    <span class="c1"># TODO(mattjj): remove this special case after dynamic shapes are integrated</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># For use in typing annotations to denote either a Tracer or a `valid_jaxtype`.</span>
<span class="n">Value</span> <span class="o">=</span> <span class="n">Any</span>

<span class="k">def</span> <span class="nf">valid_jaxtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">concrete_aval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">check_valid_jaxtype</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_jaxtype</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
      <span class="sa">f</span><span class="s2">&quot;Value </span><span class="si">{</span><span class="n">x</span><span class="si">!r}</span><span class="s2"> of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not a valid JAX type&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">concrete_aval</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
    <span class="n">handler</span> <span class="o">=</span> <span class="n">pytype_aval_mappings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">handler</span><span class="p">:</span> <span class="k">return</span> <span class="n">handler</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;__jax_array__&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">concrete_aval</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">__jax_array__</span><span class="p">())</span>
  <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value </span><span class="si">{</span><span class="n">x</span><span class="si">!r}</span><span class="s2"> with type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not a valid JAX &quot;</span>
                   <span class="s2">&quot;type&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">concrete_aval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">concretization_function_error</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">suggest_astype</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">fname</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
  <span class="n">fname_context</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The problem arose with the `</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">` function. &quot;</span>
  <span class="k">if</span> <span class="n">suggest_astype</span><span class="p">:</span>
    <span class="n">fname_context</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;If trying to convert the data type of a value, &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;try using `x.astype(</span><span class="si">{</span><span class="n">fun</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">)` &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;or `jnp.array(x, </span><span class="si">{</span><span class="n">fun</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">)` instead.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">fun</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
      <span class="k">raise</span> <span class="n">TracerBoolConversionError</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">fun</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">hex</span><span class="p">,</span> <span class="nb">oct</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
      <span class="k">raise</span> <span class="n">TracerIntegerConversionError</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
      <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">fname_context</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">error</span>

<span class="k">def</span> <span class="nf">concrete_or_error</span><span class="p">(</span><span class="n">force</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Like force(val), but gives the context in the error message.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">force</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">force</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">ConcreteArray</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">force</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">force</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">concrete_dim_or_error</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Like concrete_or_error(operator.index), allowing symbolic dimensions.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">is_dim</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">val</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>

<span class="c1">### Extended dtypes</span>
<span class="c1">#</span>
<span class="c1"># Extended dtypes are JAX-specific dtypes that allow us to represent logical</span>
<span class="c1"># arrays of element types that do not have an obvious direct correspondence</span>
<span class="c1"># to (&quot;physical&quot;) arrays of basic types in a compiler. In particular, their</span>
<span class="c1"># element types differ from those of XLA and NumPy (e.g. int32). These dtypes</span>
<span class="c1"># are only known to JAX. Their implementation is determined by:</span>
<span class="c1"># a) an object representing the extended dtype, accessible via the `dtype`</span>
<span class="c1">#    attribute on corresponding JAX arrays and, internally, on avals such</span>
<span class="c1">#    as ShapedArrays that correspond to such JAX arrays;</span>
<span class="c1"># b) a set of rules, available via a private attribute on the extended dtype</span>
<span class="c1">#    object in (a).</span>
<span class="c1"># The rules in (b) tell JAX internals how to ground out the element</span>
<span class="c1"># type for interaction with the compiler and runtime, e.g. when lowering</span>
<span class="c1"># to the compiler&#39;s language.</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">physical_aval</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapedArray</span><span class="p">:</span> <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">physical_aval</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">DShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DShapedArray</span><span class="p">:</span> <span class="o">...</span>
<span class="nd">@overload</span>                       <span class="c1"># TODO(frostig): remove this case</span>
<span class="k">def</span> <span class="nf">physical_aval</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">physical_aval</span><span class="p">(</span><span class="n">aval</span><span class="p">):</span>
  <span class="n">aval_dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">aval_dtype</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aval_dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">ExtendedDType</span><span class="p">):</span>
    <span class="n">ctor</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>
    <span class="n">aval_shape</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">aval_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="n">ctor</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>
    <span class="n">elt_aval</span> <span class="o">=</span> <span class="n">aval_dtype</span><span class="o">.</span><span class="n">_rules</span><span class="o">.</span><span class="n">physical_element_aval</span><span class="p">(</span><span class="n">aval_dtype</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">elt_aval</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ShapedArray</span>
    <span class="k">return</span> <span class="n">ctor</span><span class="p">((</span><span class="o">*</span><span class="n">aval_shape</span><span class="p">,</span> <span class="o">*</span><span class="n">elt_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">elt_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># pytype: disable=wrong-arg-count</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">aval</span>

<span class="k">def</span> <span class="nf">_short_dtype_name</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">ExtendedDType</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;uint&#39;</span>   <span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">)</span>
                      <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;int&#39;</span>  <span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_dtype_object</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">dtype</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">ExtendedDType</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">UnshapedArray</span><span class="p">(</span><span class="n">AbstractValue</span><span class="p">):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;weak_type&#39;</span><span class="p">]</span>
  <span class="n">array_abstraction_level</span> <span class="o">=</span> <span class="mi">4</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype_object</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">=</span> <span class="n">weak_type</span>

  <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span>
    <span class="k">return</span> <span class="n">UnshapedArray</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># can use hash(self.dtype) and rely on the fact that numpy reuses base dtype</span>
    <span class="c1"># objects, e.g. `np.zeros(3).dtype is np.zeros(4).dtype`, or we can use</span>
    <span class="c1"># the unique character code via hash(self.dtype.char)</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span><span class="p">))</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">str_short</span><span class="p">(),</span>
                             <span class="s2">&quot;, weak_type=True&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

  <span class="n">_bool</span>    <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
  <span class="n">_int</span>     <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
  <span class="n">_float</span>   <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
  <span class="n">_complex</span> <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">complex</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
  <span class="n">_hex</span>     <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">hex</span><span class="p">)</span>
  <span class="n">_oct</span>     <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">oct</span><span class="p">)</span>
  <span class="n">_index</span>   <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">at_least_vspace</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">UnshapedArray</span><span class="p">(</span><span class="n">primal_dtype_to_tangent_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UnshapedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short_dtypes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_short_dtype_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">short_dtypes</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>

  <span class="k">def</span> <span class="nf">strip_weak_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a copy of the aval with weak_type=False.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;UnshapedArray has no shape. Please open an issue at &quot;</span>
           <span class="s2">&quot;https://github.com/google/jax/issues because it&#39;s unexpected for &quot;</span>
           <span class="s2">&quot;UnshapedArray instances to ever be produced.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ShapedArray</span><span class="p">(</span><span class="n">UnshapedArray</span><span class="p">):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;named_shape&#39;</span><span class="p">]</span>
  <span class="n">array_abstraction_level</span> <span class="o">=</span> <span class="mi">2</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">named_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype_object</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">=</span> <span class="n">weak_type</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">named_shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">(</span><span class="n">named_shape</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span>
    <span class="k">if</span> <span class="n">named_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">named_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span>
    <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">,</span> <span class="n">named_shape</span><span class="p">)</span>

  <span class="n">ndim</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
  <span class="n">size</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span>
                  <span class="mi">0</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                  <span class="k">else</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

  <span class="n">broadcast</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">aval_method</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="n">transpose</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">aval_method</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="n">reshape</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">aval_method</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="n">_iter</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">staticmethod</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">named_shape</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># can use hash(self.dtype) and rely on the fact that numpy reuses base dtype</span>
    <span class="c1"># objects, e.g. `np.zeros(3).dtype is np.zeros(4).dtype`, or we can use</span>
    <span class="c1"># the unique character code via hash(self.dtype.char)</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span><span class="p">,</span>
                 <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

  <span class="k">def</span> <span class="nf">at_least_vspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">primal_dtype_to_tangent_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">definitely_equal_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span>
      <span class="n">named_shape</span> <span class="o">=</span> <span class="n">join_named_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">named_shape</span><span class="p">)</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">weak_type</span><span class="o">=</span><span class="n">weak_type</span><span class="p">,</span> <span class="n">named_shape</span><span class="o">=</span><span class="n">named_shape</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">UnshapedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short_dtypes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">dt_str</span> <span class="o">=</span>  <span class="n">_short_dtype_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">short_dtypes</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
    <span class="n">shapestr</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span><span class="p">:</span>
      <span class="n">named_shapestr</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
      <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dt_str</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">shapestr</span><span class="si">}</span><span class="s1">;</span><span class="si">{</span><span class="n">named_shapestr</span><span class="si">}</span><span class="s1">]&#39;</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dt_str</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">shapestr</span><span class="si">}</span><span class="s1">]&#39;</span>

  <span class="k">def</span> <span class="nf">strip_named_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">named_shape</span><span class="o">=</span><span class="p">{})</span>

  <span class="k">def</span> <span class="nf">_len</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignored_tracer</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;len() of unsized object&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>  <span class="c1"># same as numpy error</span>


<span class="k">def</span> <span class="nf">_forward_to_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">ignored_tracer</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ConcreteArray</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span>
  <span class="n">array_abstraction_level</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">dtype</span><span class="p">,</span>
        <span class="n">weak_type</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">weak_type</span><span class="p">)</span>
    <span class="n">dtypes</span><span class="o">.</span><span class="n">check_valid_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># Note: canonicalized self.dtype doesn&#39;t necessarily match self.val</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">val</span><span class="p">)),</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

  <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
    <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">val</span>
    <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="k">if</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">weak_type</span>
    <span class="k">return</span> <span class="n">ConcreteArray</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span>
        <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span><span class="p">):</span>
      <span class="k">with</span> <span class="n">eval_context</span><span class="p">():</span>  <span class="c1"># in case self.val is an Array</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">False</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
    <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span>
      <span class="n">named_shape</span> <span class="o">=</span> <span class="n">join_named_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">named_shape</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="n">weak_type</span><span class="p">,</span> <span class="n">named_shape</span><span class="o">=</span><span class="n">named_shape</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">UnshapedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">weak_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short_dtypes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">dt_str</span> <span class="o">=</span>  <span class="n">_short_dtype_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">short_dtypes</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s1">, dtype=</span><span class="si">{</span><span class="n">dt_str</span><span class="si">}</span><span class="s1">&#39;</span>

  <span class="n">_bool</span>    <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="n">_forward_to_value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
  <span class="n">_int</span>     <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="n">_forward_to_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="n">_hex</span>     <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="n">_forward_to_value</span><span class="p">,</span> <span class="nb">hex</span><span class="p">)</span>
  <span class="n">_oct</span>     <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="n">_forward_to_value</span><span class="p">,</span> <span class="nb">oct</span><span class="p">)</span>
  <span class="n">_index</span>   <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="n">_forward_to_value</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

  <span class="n">_float</span>   <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
  <span class="n">_complex</span> <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">complex</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">primal_dtype_to_tangent_dtype</span><span class="p">(</span><span class="n">primal_dtype</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">primal_dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">ExtendedDType</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">primal_dtype</span><span class="o">.</span><span class="n">_rules</span><span class="o">.</span><span class="n">tangent_dtype</span><span class="p">(</span><span class="n">primal_dtype</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
  <span class="k">elif</span> <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">primal_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">primal_dtype</span>


<span class="c1"># Dynamic shape stuff below here! We keep the abstract values distinct just so</span>
<span class="c1"># as not to interfere with any static shape machinery.</span>

<span class="c1"># We have a convention of reusing AbsractValues as types, even though we could</span>
<span class="c1"># make a distinction and use abstract values during tracing only. This reuse</span>
<span class="c1"># becomes a bit more extreme with DShapedArrays. A DShapedArray&#39;s shape</span>
<span class="c1"># attribute is a tuple which can contain several different types: int, DArray</span>
<span class="c1"># (scalar and with dtype of bint type), Tracer (while tracing), Var (when used</span>
<span class="c1"># as jaxpr type annotations), or DBIdx/InDBIdx/OutDBIdx (when used in InputType</span>
<span class="c1"># or OutputType). We could reduce this polymorphism if it seems cleaner, though</span>
<span class="c1"># it&#39;s kind of convenient!</span>
<span class="k">class</span> <span class="nc">DShapedArray</span><span class="p">(</span><span class="n">UnshapedArray</span><span class="p">):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
  <span class="n">shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AxisSize</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>  <span class="c1"># noqa: F821</span>
  <span class="n">array_abstraction_level</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">=</span> <span class="n">weak_type</span>

  <span class="n">ndim</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
  <span class="n">size</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span>
                  <span class="mi">0</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                  <span class="k">else</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short_dtypes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">del</span> <span class="n">short_dtypes</span>  <span class="c1"># ignored</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">_short_dtype_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s1">]&#39;</span>
  <span class="fm">__str__</span> <span class="o">=</span> <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">str_short</span>

  <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span>
    <span class="k">return</span> <span class="n">DShapedArray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">_len</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">definitely_equal_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
      <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">weak_type</span><span class="o">=</span><span class="n">weak_type</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">UnshapedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">at_least_vspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">DShapedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">primal_dtype_to_tangent_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DConcreteArray</span><span class="p">(</span><span class="n">DShapedArray</span><span class="p">):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span>
  <span class="n">array_abstraction_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>


<span class="n">pytype_aval_mappings</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">AbstractValue</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">class</span> <span class="nc">DArray</span><span class="p">:</span>
  <span class="n">_aval</span><span class="p">:</span> <span class="n">DShapedArray</span>
  <span class="n">_data</span><span class="p">:</span> <span class="n">Any</span>  <span class="c1"># standard array type</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">pad_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">bound</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">DArray</span> <span class="ow">and</span>
                      <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">is</span> <span class="n">bint</span> <span class="k">else</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">pad_shape</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_aval</span> <span class="o">=</span> <span class="n">aval</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">aval</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aval</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">is</span> <span class="n">bint</span><span class="p">:</span>
      <span class="c1"># special-case scalar bints</span>
      <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="se">{{</span><span class="s1">â‰¤</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">bound</span><span class="si">}</span><span class="se">}}</span><span class="s1">&#39;</span>

    <span class="n">dtypestr</span> <span class="o">=</span> <span class="n">_short_dtype_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">shapestr</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">_data</span><span class="p">))</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">DArray</span> <span class="ow">and</span>
                   <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">is</span> <span class="n">bint</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dtypestr</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">shapestr</span><span class="si">}</span><span class="s1">] with value: </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s1">&#39;</span>
  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
      <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_aval</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)))</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unhashable type: DArray&quot;</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DArray</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aval</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_aval</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_data</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">pytype_aval_mappings</span><span class="p">[</span><span class="n">DArray</span><span class="p">]</span> <span class="o">=</span> \
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">DConcreteArray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">,</span>
                             <span class="n">x</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">bint</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">ExtendedDType</span><span class="p">):</span>
  <span class="n">bound</span><span class="p">:</span> <span class="nb">int</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">extended</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;bint</span><span class="se">{{</span><span class="s1">â‰¤</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="si">}</span><span class="se">}}</span><span class="s1">&#39;</span>

  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<span class="n">AxisSize</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">DArray</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">,</span> <span class="n">Var</span><span class="p">,</span> <span class="n">DBIdx</span><span class="p">,</span> <span class="n">InDBIdx</span><span class="p">,</span> <span class="n">OutDBIdx</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">MutableArray</span><span class="p">:</span>
  <span class="n">_aval</span><span class="p">:</span> <span class="n">ShapedArray</span>
  <span class="n">_buf</span><span class="p">:</span> <span class="n">Array</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="n">buf</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_aval</span> <span class="o">=</span> <span class="n">aval</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_buf</span> <span class="o">=</span> <span class="n">buf</span>
  <span class="n">aval</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aval</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span> <span class="k">return</span> <span class="n">get_aval</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">get_aval</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;Mutable&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">])</span>
<span class="n">pytype_aval_mappings</span><span class="p">[</span><span class="n">MutableArray</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">_aval</span>

<span class="k">def</span> <span class="nf">mutable_array</span><span class="p">(</span><span class="n">init_val</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">mutable_array_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span>
<span class="n">mutable_array_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s1">&#39;mutable_array&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">InternalMutableArray</span><span class="p">(</span><span class="n">effects</span><span class="o">.</span><span class="n">Effect</span><span class="p">):</span>
  <span class="k">pass</span>

<span class="nd">@mutable_array_p</span><span class="o">.</span><span class="n">def_effectful_abstract_eval</span>
<span class="k">def</span> <span class="nf">mutable_array_abstract_eval</span><span class="p">(</span><span class="n">init_aval</span><span class="p">):</span>
  <span class="kn">from</span> <span class="nn">jax._src.state.types</span> <span class="kn">import</span> <span class="n">AbstractRef</span>  <span class="c1"># type: ignore[import]</span>
  <span class="k">return</span> <span class="n">AbstractRef</span><span class="p">(</span><span class="n">init_aval</span><span class="p">),</span> <span class="p">{</span><span class="n">InternalMutableArray</span><span class="p">}</span>

<span class="nd">@mutable_array_p</span><span class="o">.</span><span class="n">def_impl</span>
<span class="k">def</span> <span class="nf">_mutable_array_impl</span><span class="p">(</span><span class="n">init_val</span><span class="p">):</span>
  <span class="kn">from</span> <span class="nn">jax._src.state.types</span> <span class="kn">import</span> <span class="n">AbstractRef</span>  <span class="c1"># type: ignore[import]</span>
  <span class="n">aval</span> <span class="o">=</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">init_val</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">MutableArray</span><span class="p">(</span><span class="n">AbstractRef</span><span class="p">(</span><span class="n">aval</span><span class="p">),</span> <span class="n">init_val</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AbstractToken</span><span class="p">(</span><span class="n">AbstractValue</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AbstractToken</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Cannot join </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">other</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short_dtypes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;Tok&#39;</span>
  <span class="k">def</span> <span class="nf">at_least_vspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span>
<span class="n">abstract_token</span><span class="p">:</span> <span class="n">AbstractToken</span> <span class="o">=</span> <span class="n">AbstractToken</span><span class="p">()</span>

<span class="c1"># Concrete token object</span>
<span class="k">class</span> <span class="nc">Token</span><span class="p">:</span> <span class="k">pass</span>
<span class="n">token</span><span class="p">:</span> <span class="n">Token</span> <span class="o">=</span> <span class="n">Token</span><span class="p">()</span>
<span class="n">pytype_aval_mappings</span><span class="p">[</span><span class="n">Token</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">abstract_token</span>


<span class="k">def</span> <span class="nf">raise_to_shaped</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">aval_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">aval_type</span> <span class="ow">is</span> <span class="n">ShapedArray</span> <span class="ow">and</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">aval</span>
  <span class="k">if</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">weak_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="s1">&#39;weak_type&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">aval_type</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
    <span class="n">handler</span> <span class="o">=</span> <span class="n">raise_to_shaped_mappings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">handler</span><span class="p">:</span> <span class="k">return</span> <span class="n">handler</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">)</span>
  <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">))</span>

<span class="n">raise_to_shaped_mappings</span> <span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">AbstractToken</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">aval</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">aval</span><span class="p">,</span>
  <span class="n">Bot</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">aval</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">aval</span><span class="p">,</span>
  <span class="n">UnshapedArray</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">aval</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">aval</span><span class="p">,</span>
  <span class="n">ShapedArray</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">aval</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">(</span>
      <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">named_shape</span><span class="p">),</span>
  <span class="n">DConcreteArray</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">aval</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">:</span> <span class="n">DShapedArray</span><span class="p">(</span>
      <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">),</span>
<span class="p">}</span>

<span class="c1">### Operations on shapes and dimension sizes.</span>

<span class="k">class</span> <span class="nc">InconclusiveDimensionOperation</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Raised when we cannot conclusively compute with symbolic dimensions.&quot;&quot;&quot;</span>
  <span class="k">pass</span>

<span class="k">def</span> <span class="nf">is_symbolic_dim</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Checks if a value is a symbolic dimension used for shape polymorphism.</span>

<span class="sd">  This should be used very rarely, because symbolic dimensions overload all</span>
<span class="sd">  operators, and should just work.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;dimension_as_value&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_constant_dim</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="c1"># Whether the dimension is a static integer constant.</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span>
  <span class="k">except</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">is_dim</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">is_symbolic_dim</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_constant_dim</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_constant_shape</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="c1"># Whether the shape is a static constant.</span>
  <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">definitely_equal_one_of_dim</span><span class="p">(</span><span class="n">d1</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">dlist</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DimSize</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">definitely_equal</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dlist</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">definitely_equal_shape</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Check that two shapes are guaranteed to be element-wise equal.</span>

<span class="sd">  In presence of dynamic shapes may return False even when the shapes may</span>
<span class="sd">  be equal at runtime.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="ow">and</span>
          <span class="nb">all</span><span class="p">(</span><span class="n">unsafe_map</span><span class="p">(</span><span class="n">definitely_equal</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">divide_shape_sizes</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Returns an integer &quot;i&quot; s.t., i * size(s2) == size(s1).</span>
<span class="sd">  Raises InconclusiveDimensionOperation if there is no such integer.&quot;&quot;&quot;</span>
  <span class="n">sz1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
  <span class="n">sz2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">definitely_equal</span><span class="p">(</span><span class="n">sz1</span><span class="p">,</span> <span class="n">sz2</span><span class="p">):</span>  <span class="c1"># Takes care of sz1 and sz2 being 0</span>
    <span class="k">return</span> <span class="mi">1</span>
  <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">sz1</span><span class="p">,</span> <span class="n">sz2</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">InconclusiveDimensionOperation</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Cannot divide evenly the sizes of shapes </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span><span class="si">}</span><span class="s2">. &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;The remainder </span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s2"> should be 0.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">q</span>

<span class="k">def</span> <span class="nf">cancel_divide_tracers</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">):</span>
  <span class="n">partition</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">partition_list</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">l</span><span class="p">],</span> <span class="n">l</span><span class="p">)</span>
  <span class="n">num</span><span class="p">,</span> <span class="n">num_tracers</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
  <span class="n">denom</span><span class="p">,</span> <span class="n">denom_tracers</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">num_tracers</span> <span class="ow">or</span> <span class="n">denom_tracers</span><span class="p">:</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">_cancel_divide</span><span class="p">(</span><span class="n">num_tracers</span><span class="p">,</span> <span class="n">denom_tracers</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">size1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
      <span class="n">size2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">size1</span> <span class="o">==</span> <span class="n">size2</span> <span class="ow">or</span> <span class="n">size2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">size1</span> <span class="o">//</span> <span class="n">size2</span> <span class="k">if</span> <span class="n">size1</span> <span class="o">!=</span> <span class="n">size2</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_cancel_divide</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">):</span>
  <span class="n">num</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">denom</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">if</span> <span class="n">definitely_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">break</span>  <span class="c1"># couldn&#39;t cancel</span>
    <span class="k">del</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_empty_shape</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">definitely_equal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dilate_dim</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">dilation</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;max(0, 1 + dilation * (d - 1)).</span>

<span class="sd">  Assumes dilation &gt;= 1.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">definitely_equal</span><span class="p">(</span><span class="n">dilation</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># fast path</span>
    <span class="k">return</span> <span class="n">d</span>
  <span class="k">return</span> <span class="n">max_dim</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dilation</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">stride_dim</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">window_size</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">window_stride</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;max(0, (d - window_size) // window_stride + 1)</span>

<span class="sd">  If d &lt; window_size, returns 0.</span>
<span class="sd">  We assume window_size &gt;= 1 and window_stride &gt;= 1.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># If d &lt; window_size then (d - window_size) // window_stride &lt; 0</span>
  <span class="k">return</span> <span class="n">max_dim</span><span class="p">((</span><span class="n">d</span> <span class="o">-</span> <span class="n">window_size</span><span class="p">)</span> <span class="o">//</span> <span class="n">window_stride</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># TODO(necula): Deprecated Jan 2024, to be removed.</span>
<span class="k">def</span> <span class="nf">non_negative_dim</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;max(d, 0).&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">max_dim</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">min_dim</span><span class="p">(</span><span class="n">d1</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">d2</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Like min(d1, d2) but for both constant and symbolic dimensions.&quot;&quot;&quot;</span>
  <span class="n">d1_is_constant</span> <span class="o">=</span> <span class="n">is_constant_dim</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">d1_is_constant</span> <span class="ow">and</span> <span class="n">is_constant_dim</span><span class="p">(</span><span class="n">d2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">d1_is_constant</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">d2</span><span class="o">.</span><span class="n">rmin</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">d1</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>

<span class="k">def</span> <span class="nf">max_dim</span><span class="p">(</span><span class="n">d1</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">d2</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Like max(d1, d2) but for both constant and symbolic dimensions.&quot;&quot;&quot;</span>
  <span class="n">d1_is_constant</span> <span class="o">=</span> <span class="n">is_constant_dim</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">d1_is_constant</span> <span class="ow">and</span> <span class="n">is_constant_dim</span><span class="p">(</span><span class="n">d2</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">d1_is_constant</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">d2</span><span class="o">.</span><span class="n">rmax</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">d1</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>

<span class="k">def</span> <span class="nf">dimension_as_value</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Turns a dimension size into a JAX array.</span>
<span class="sd">     This is the identity function for constant dimensions.</span>

<span class="sd">     Has the same abstract value as Python constants.</span>
<span class="sd">     &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span> <span class="k">return</span> <span class="n">d</span>
  <span class="c1"># For shape_poly._DimPolynomial</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s2">&quot;dimension_as_value&quot;</span><span class="p">):</span> <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">dimension_as_value</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_canonicalize_dimension</span><span class="p">(</span><span class="n">dim</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
  <span class="c1"># Dimensions are most commonly integral (by far), so we check that first.</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">type_error</span> <span class="o">=</span> <span class="n">e</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">config</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dim</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dim</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
                               <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">bint</span><span class="p">))):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dimensions must be integer scalars; got </span><span class="si">{</span><span class="n">dim</span><span class="o">.</span><span class="n">ndim</span><span class="si">=}</span><span class="s2"> </span><span class="si">{</span><span class="n">dim</span><span class="o">.</span><span class="n">dtype</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dim</span>
  <span class="k">elif</span> <span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">value</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">DArray</span><span class="p">)</span> <span class="ow">and</span>
        <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">is</span> <span class="n">bint</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dim</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dim</span>
  <span class="k">elif</span> <span class="n">is_dim</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dim</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">type_error</span>

<span class="k">def</span> <span class="nf">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Canonicalizes and checks for errors in a user-provided shape value.</span>

<span class="sd">  Args:</span>
<span class="sd">    shape: a Python value that represents a shape.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A tuple of canonical dimension values.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">unsafe_map</span><span class="p">(</span><span class="n">_canonicalize_dimension</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="k">pass</span>
  <span class="k">raise</span> <span class="n">_invalid_shape_error</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">canonicalize_dim</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Canonicalizes and checks for errors in a user-provided shape dimension value.</span>

<span class="sd">  Args:</span>
<span class="sd">    f: a Python value that represents a dimension.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A canonical dimension value.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">canonicalize_shape</span><span class="p">((</span><span class="n">d</span><span class="p">,),</span> <span class="n">context</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_invalid_shape_error</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Shapes must be 1D sequences of integer scalars, &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Shapes must be 1D sequences of concrete values of integer type, &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">context</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">context</span><span class="si">}</span><span class="s2">.&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">config</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">value</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
         <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ShapedArray</span><span class="p">)</span>
         <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ConcreteArray</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">If using `jit`, try using `static_argnums` or applying `jit` to &quot;</span>
            <span class="s2">&quot;smaller subfunctions.&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;_origin_msg&quot;</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="n">x</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span>

  <span class="k">return</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SomeTracer</span><span class="p">:</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s2">&quot;[dynamic]&quot;</span>

<span class="k">def</span> <span class="nf">replace_tracer_for_error_message</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
  <span class="c1"># TODO(mattjj): Many ideas for improving this.  Crawl the stack and see if</span>
  <span class="c1"># there are user variables whose value is == to this object?  Or search</span>
  <span class="c1"># parameters of functions being transformed, at least?  Or at least assign</span>
  <span class="c1"># short unique ids to them?</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">SomeTracer</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">obj</span>

<span class="k">def</span> <span class="nf">evaluate_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">dim_vars</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                   <span class="o">*</span><span class="n">dim_values</span><span class="p">:</span> <span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Evaluates a shape possibly containing non-constants.</span>

<span class="sd">  Args:</span>
<span class="sd">    shape: the shape to evaluate.</span>
<span class="sd">    dim_vars: the dimension variables names that may appear in `shape`.</span>
<span class="sd">    dim_values: the dimension values corresponding to `dim_vars`.</span>

<span class="sd">  Returns:</span>
<span class="sd">     a tuple of JAX values corresponding to `shape`, of type</span>
<span class="sd">     `dim_value_dtype`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">env</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dim_vars</span><span class="p">,</span> <span class="n">dim_values</span><span class="p">))</span>
  <span class="k">def</span> <span class="nf">eval_one_dim</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
      <span class="c1"># Is a _DimExpr</span>
      <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">eval_one_dim</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dim_value_dtype</span><span class="p">():</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;The dtype to be used for dimension values.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dim_constant</span><span class="p">(</span><span class="n">ct</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dim_value_dtype</span><span class="p">()</span>
  <span class="k">assert</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dim_value_aval</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">((),</span> <span class="n">dim_value_dtype</span><span class="p">(),</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># ------------------- Named shapes -------------------</span>


<span class="k">class</span> <span class="nc">NamedShape</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__positional</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="c1"># TODO: Assert that kwargs match axis env?</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__named</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">positional_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">named_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">positional</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__positional</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">named_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">named_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

  <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">idx</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="k">pass</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">:</span> <span class="n">total</span> <span class="o">*=</span> <span class="n">s</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="o">.</span><span class="n">values</span><span class="p">():</span> <span class="n">total</span> <span class="o">*=</span> <span class="n">s</span>
    <span class="k">return</span> <span class="n">total</span>

  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># TODO(mattjj,frostig): revise not to miss commas</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="p">:</span>
      <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">))</span><span class="si">}{</span><span class="s1">&#39;, &#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="o">.</span><span class="n">items</span><span class="p">())</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NamedShape</span><span class="p">):</span>
      <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__positional</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">__named</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
      <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__positional</span> <span class="o">==</span> <span class="n">other</span>
    <span class="k">return</span> <span class="kc">False</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">named</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">,</span> <span class="n">named</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">join_named_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">named_shapes</span><span class="p">):</span>
  <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">for</span> <span class="n">named_shape</span> <span class="ow">in</span> <span class="n">named_shapes</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">named_shape</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Axis name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> used with inconsistent sizes: </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>

<span class="c1"># TODO: Make canonicalize_shape return named shapes?</span>
<span class="k">def</span> <span class="nf">as_named_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NamedShape</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">NamedShape</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">shape</span>
  <span class="k">return</span> <span class="n">NamedShape</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">)</span>


<span class="c1"># ------------------- Call -------------------</span>

<span class="k">class</span> <span class="nc">CallPrimitive</span><span class="p">(</span><span class="n">Primitive</span><span class="p">):</span>
  <span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">call_primitive</span> <span class="o">=</span> <span class="kc">True</span>

  <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="n">call_bind_continuation</span><span class="p">,</span> <span class="n">top_trace</span><span class="p">,</span> <span class="n">fun_</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">call_bind_with_continuation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">))</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">top_trace</span><span class="o">.</span><span class="n">process_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun_</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">call_bind_continuation</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">get_bind_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">new_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">new_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;call_jaxpr&#39;</span><span class="p">)</span>
    <span class="n">subfun</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">hashable_partial</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">wrap_init</span><span class="p">(</span><span class="n">eval_jaxpr</span><span class="p">),</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="p">())</span>
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
      <span class="n">subfun</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">subfun</span><span class="p">,</span> <span class="n">_jaxpr_type_to_callable_annotation</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">subfun</span><span class="p">],</span> <span class="n">new_params</span>

<span class="k">def</span> <span class="nf">call_bind_with_continuation</span><span class="p">(</span><span class="n">primitive</span><span class="p">:</span> <span class="n">CallPrimitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="n">top_trace</span> <span class="o">=</span> <span class="n">find_top_trace</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">fun_</span><span class="p">,</span> <span class="n">env_trace_todo</span> <span class="o">=</span> <span class="n">process_env_traces_call</span><span class="p">(</span>
      <span class="n">fun</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">top_trace</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
  <span class="n">tracers</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">top_trace</span><span class="o">.</span><span class="n">full_raise</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="n">fun_</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">fun_</span><span class="p">,</span> <span class="n">fun</span><span class="o">.</span><span class="n">in_type</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">call_bind_continuation</span><span class="p">(</span><span class="n">outs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">full_lower</span><span class="p">,</span> <span class="n">apply_todos</span><span class="p">(</span><span class="n">env_trace_todo</span><span class="p">(),</span> <span class="n">outs</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">call_bind_continuation</span><span class="p">,</span> <span class="n">top_trace</span><span class="p">,</span> <span class="n">fun_</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span>

<span class="nd">@lu</span><span class="o">.</span><span class="n">transformation_with_aux</span>
<span class="k">def</span> <span class="nf">process_env_traces_call</span><span class="p">(</span><span class="n">primitive</span><span class="p">:</span> <span class="n">CallPrimitive</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                            <span class="n">params_tuple</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">args</span><span class="p">,</span> <span class="p">{}</span>
  <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params_tuple</span><span class="p">)</span>
  <span class="n">todo</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">tracers</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">outs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tracers</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tracers</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">_get_trace_level</span><span class="p">)</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">ans</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">with_cur_sublevel</span><span class="p">()</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">full_raise</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span>
    <span class="n">outs</span><span class="p">,</span> <span class="n">cur_todo</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">post_process_call</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">outs</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">todo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_todo</span><span class="p">)</span>
  <span class="k">yield</span> <span class="n">outs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span>  <span class="c1"># Ensure the aux output is immutable</span>

<span class="k">def</span> <span class="nf">apply_todos</span><span class="p">(</span><span class="n">todos</span><span class="p">,</span> <span class="n">outs</span><span class="p">):</span>
  <span class="n">todos_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">todos</span><span class="p">)</span>
  <span class="k">while</span> <span class="n">todos_list</span><span class="p">:</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">full_lower</span><span class="p">,</span> <span class="n">todos_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()(</span><span class="n">outs</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">outs</span>


<span class="k">def</span> <span class="nf">call_impl</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">lu</span><span class="o">.</span><span class="n">WrappedFun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">params</span>  <span class="c1"># params parameterize the call primitive, not the function</span>
  <span class="k">with</span> <span class="n">new_sublevel</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">call_wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="n">call_p</span><span class="p">:</span> <span class="n">CallPrimitive</span> <span class="o">=</span> <span class="n">CallPrimitive</span><span class="p">(</span><span class="s1">&#39;call&#39;</span><span class="p">)</span>
<span class="n">call</span> <span class="o">=</span> <span class="n">call_p</span><span class="o">.</span><span class="n">bind</span>
<span class="n">call_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">call_impl</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ClosedCallPrimitive</span><span class="p">(</span><span class="n">CallPrimitive</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">get_bind_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">new_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">new_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;call_jaxpr&#39;</span><span class="p">)</span>
    <span class="n">subfun</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">wrap_init</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">eval_jaxpr</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">subfun</span><span class="p">],</span> <span class="n">new_params</span>

<span class="n">closed_call_p</span><span class="p">:</span> <span class="n">ClosedCallPrimitive</span> <span class="o">=</span> <span class="n">ClosedCallPrimitive</span><span class="p">(</span><span class="s1">&#39;closed_call&#39;</span><span class="p">)</span>
<span class="n">closed_call_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">call_impl</span><span class="p">)</span>


<span class="n">outfeed_primitives</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Primitive</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">jaxpr_uses_outfeed</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Finds if there are outfeed primitives anywhere inside a Jaxpr.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">primitive_uses_outfeed</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_param_uses_outfeed</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Jaxpr</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">jaxpr_uses_outfeed</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
      <span class="k">return</span> <span class="kc">True</span>
  <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ClosedJaxpr</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">jaxpr_uses_outfeed</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">):</span>
      <span class="k">return</span> <span class="kc">True</span>
  <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">primitive_uses_outfeed</span><span class="p">(</span><span class="n">prim</span><span class="p">:</span> <span class="n">Primitive</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">prim</span> <span class="ow">in</span> <span class="n">outfeed_primitives</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">True</span>
  <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">unsafe_map</span><span class="p">(</span><span class="n">_param_uses_outfeed</span><span class="p">,</span> <span class="n">param</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">_param_uses_outfeed</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
      <span class="k">return</span> <span class="kc">True</span>
  <span class="k">return</span> <span class="kc">False</span>

<span class="c1"># ------------------- Map -------------------</span>

<span class="k">class</span> <span class="nc">MapPrimitive</span><span class="p">(</span><span class="n">Primitive</span><span class="p">):</span>
  <span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">map_primitive</span> <span class="o">=</span> <span class="kc">True</span>

  <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;in_axes&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">map_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">process_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">out_tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">post_process_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">get_bind_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">new_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">new_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;call_jaxpr&#39;</span><span class="p">)</span>
    <span class="n">subfun</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">hashable_partial</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">wrap_init</span><span class="p">(</span><span class="n">eval_jaxpr</span><span class="p">),</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="p">())</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">new_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;out_axes&#39;</span><span class="p">)</span>
    <span class="n">new_params</span><span class="p">[</span><span class="s1">&#39;out_axes_thunk&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HashableFunction</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">axes</span><span class="p">,</span> <span class="n">closure</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">subfun</span><span class="p">],</span> <span class="n">new_params</span>


<span class="k">def</span> <span class="nf">map_bind_with_continuation</span><span class="p">(</span><span class="n">primitive</span><span class="p">:</span> <span class="n">MapPrimitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                               <span class="n">out_axes_thunk</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="c1"># The new thunk depends deterministically on the old thunk and the wrapped</span>
  <span class="c1"># function. Any caching already has to include the wrapped function as part</span>
  <span class="c1"># of the key, so we only use the previous thunk for equality checks.</span>
  <span class="nd">@as_hashable_function</span><span class="p">(</span><span class="n">closure</span><span class="o">=</span><span class="n">out_axes_thunk</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">new_out_axes_thunk</span><span class="p">():</span>
    <span class="n">out_axes</span> <span class="o">=</span> <span class="n">out_axes_thunk</span><span class="p">()</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">out_axes_transforms</span> <span class="o">=</span> <span class="n">todo_and_xforms</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">out_axes_transforms</span><span class="p">:</span>
      <span class="n">out_axes</span> <span class="o">=</span> <span class="n">t</span><span class="p">(</span><span class="n">out_axes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out_axes</span>
  <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">out_axes_thunk</span><span class="o">=</span><span class="n">new_out_axes_thunk</span><span class="p">)</span>
  <span class="n">top_trace</span> <span class="o">=</span> <span class="n">find_top_trace</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">fun</span><span class="p">,</span> <span class="n">todo_and_xforms</span> <span class="o">=</span> <span class="n">process_env_traces_map</span><span class="p">(</span>
      <span class="n">fun</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">top_trace</span> <span class="ow">and</span> <span class="n">top_trace</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
  <span class="n">tracers</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">top_trace</span><span class="o">.</span><span class="n">full_raise</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">map_bind_continuation</span><span class="p">(</span><span class="n">outs</span><span class="p">):</span>
    <span class="n">env_trace_todo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">todo_and_xforms</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">full_lower</span><span class="p">,</span> <span class="n">apply_todos</span><span class="p">(</span><span class="n">env_trace_todo</span><span class="p">,</span> <span class="n">outs</span><span class="p">))</span>

  <span class="k">return</span> <span class="n">map_bind_continuation</span><span class="p">,</span> <span class="n">top_trace</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span>


<span class="k">def</span> <span class="nf">map_bind</span><span class="p">(</span><span class="n">primitive</span><span class="p">:</span> <span class="n">MapPrimitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="n">map_bind_continuation</span><span class="p">,</span> <span class="n">top_trace</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="p">(</span>
      <span class="n">map_bind_with_continuation</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">map_bind_continuation</span><span class="p">(</span>
      <span class="n">primitive</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">top_trace</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>

<span class="nd">@lu</span><span class="o">.</span><span class="n">transformation_with_aux</span>
<span class="k">def</span> <span class="nf">process_env_traces_map</span><span class="p">(</span><span class="n">primitive</span><span class="p">:</span> <span class="n">MapPrimitive</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                           <span class="n">params_tuple</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">args</span><span class="p">,</span> <span class="p">{}</span>
  <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params_tuple</span><span class="p">)</span>
  <span class="n">todo</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">out_axes_transforms</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">tracers</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">outs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span>
               <span class="ow">and</span> <span class="p">(</span><span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">)]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tracers</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tracers</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">_get_trace_level</span><span class="p">)</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">ans</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">with_cur_sublevel</span><span class="p">()</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">full_raise</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span>
    <span class="n">outs</span><span class="p">,</span> <span class="p">(</span><span class="n">cur_todo</span><span class="p">,</span> <span class="n">cur_xform</span><span class="p">)</span> <span class="o">=</span> <span class="n">primitive</span><span class="o">.</span><span class="n">post_process</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">outs</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">todo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_todo</span><span class="p">)</span>
    <span class="n">out_axes_transforms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_xform</span><span class="p">)</span>
  <span class="k">yield</span> <span class="n">outs</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">todo</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out_axes_transforms</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">mapped_aval</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">AxisSize</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
  <span class="n">handler</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">aval_mapping_handlers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">),</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">handler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">handler</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no mapping handler for </span><span class="si">{</span><span class="n">aval</span><span class="si">}</span><span class="s2"> of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">unmapped_aval</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">AxisSize</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">aval_mapping_handlers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">),</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">handler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">handler</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no unmapping handler for </span><span class="si">{</span><span class="n">aval</span><span class="si">}</span><span class="s2"> of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_map_shaped_array</span><span class="p">(</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapedArray</span><span class="p">:</span>
  <span class="k">assert</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">size</span>
  <span class="c1"># TODO: Extend the named shape</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">aval</span>
  <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="n">tuple_delete</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                     <span class="n">named_shape</span><span class="o">=</span><span class="n">aval</span><span class="o">.</span><span class="n">named_shape</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_unmap_shaped_array</span><span class="p">(</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">:</span> <span class="n">AxisName</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapedArray</span><span class="p">:</span>
  <span class="n">named_shape</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">named_shape</span><span class="p">)</span>
  <span class="n">named_shape</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">axis_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># TODO: make this mandatory</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">named_shape</span><span class="o">=</span><span class="n">named_shape</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="n">tuple_insert</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                       <span class="n">named_shape</span><span class="o">=</span><span class="n">named_shape</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_map_dshaped_array</span><span class="p">(</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">AxisSize</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">DShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DShapedArray</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">aval</span>
  <span class="k">return</span> <span class="n">DShapedArray</span><span class="p">(</span><span class="n">tuple_delete</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                      <span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_unmap_dshaped_array</span><span class="p">(</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">AxisSize</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">:</span> <span class="n">AxisName</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">DShapedArray</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DShapedArray</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">aval</span>
  <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">DShapedArray</span><span class="p">(</span><span class="n">tuple_insert</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                        <span class="n">weak_type</span><span class="o">=</span><span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

<span class="n">AvalMapHandlerPair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span>
<span class="n">aval_mapping_handlers</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">AvalMapHandlerPair</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">DShapedArray</span><span class="p">:</span>   <span class="p">(</span><span class="n">_map_dshaped_array</span><span class="p">,</span> <span class="n">_unmap_dshaped_array</span><span class="p">),</span>
    <span class="n">ShapedArray</span><span class="p">:</span>   <span class="p">(</span><span class="n">_map_shaped_array</span><span class="p">,</span> <span class="n">_unmap_shaped_array</span><span class="p">),</span>
    <span class="n">ConcreteArray</span><span class="p">:</span> <span class="p">(</span><span class="n">_map_shaped_array</span><span class="p">,</span> <span class="n">_unmap_shaped_array</span><span class="p">),</span>
    <span class="n">AbstractToken</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">___</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">extend_axis_env</span><span class="p">(</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">AxisName</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
  <span class="n">frame</span> <span class="o">=</span> <span class="n">AxisEnvFrame</span><span class="p">(</span><span class="n">axis_name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
  <span class="n">ts</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span>
  <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
  <span class="n">config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span>
      <span class="n">axis_env_state</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span>
                           <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">no_axis_name</span><span class="p">))</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span>
        <span class="n">axis_env_state</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span>
                             <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">no_axis_name</span><span class="p">))</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">extend_axis_env_nd</span><span class="p">(</span><span class="n">axes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">AxisName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">tag</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">AxisEnvFrame</span><span class="p">(</span><span class="n">axis_name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span> <span class="k">for</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
  <span class="n">ts</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span>
  <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
  <span class="n">config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span>
      <span class="n">axis_env_state</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span>
                           <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">no_axis_name</span><span class="p">))</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">:</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span>
        <span class="n">axis_env_state</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span>
                             <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">no_axis_name</span><span class="p">))</span>


<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">stash_axis_env</span><span class="p">():</span>
  <span class="s2">&quot;Promise that a function or with-suite does not depend implicitly on axis env&quot;</span>
  <span class="c1"># If the promise is broken, then a NameError about an unbound axis name will</span>
  <span class="c1"># be raised.</span>
  <span class="n">ts</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span>
  <span class="n">prev_axis_env</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span><span class="p">,</span> <span class="p">[]</span>
  <span class="n">config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span><span class="n">axis_env_state</span><span class="o">=</span><span class="p">())</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span> <span class="o">=</span> <span class="n">prev_axis_env</span>
    <span class="n">config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span>
        <span class="n">axis_env_state</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span>
                             <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">no_axis_name</span><span class="p">))</span>


<span class="c1"># When a mapped function is given no axis name, we generate a name object based</span>
<span class="c1"># on the id of the function object. Collisions aren&#39;t important because this</span>
<span class="c1"># name can&#39;t be used in collectives, as user code never gets a ref to this</span>
<span class="c1"># object. We don&#39;t want to use the function object itself because that might</span>
<span class="c1"># persist references to the function object.</span>
<span class="c1"># TODO(mattjj): revisit this unique axis name strategy</span>
<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">_TempAxisName</span><span class="p">:</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;axis </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="si">}</span><span class="s1">&gt;&#39;</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">_TempAxisName</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span>

  <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">_TempAxisName</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span>


<span class="k">def</span> <span class="nf">axis_frame</span><span class="p">(</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">AxisName</span><span class="p">,</span> <span class="n">main_trace</span><span class="p">:</span> <span class="n">MainTrace</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
               <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AxisEnvFrame</span><span class="p">:</span>
  <span class="n">frames</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">axis_env</span>
  <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">axis_name</span> <span class="ow">and</span>
        <span class="p">(</span><span class="n">main_trace</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">frame</span><span class="o">.</span><span class="n">main_trace</span> <span class="ow">is</span> <span class="n">main_trace</span><span class="p">)):</span>
      <span class="k">return</span> <span class="n">frame</span>
  <span class="n">named_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">frame</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">_TempAxisName</span><span class="p">)]</span>
  <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
      <span class="sa">f</span><span class="s1">&#39;unbound axis name: </span><span class="si">{</span><span class="n">axis_name</span><span class="si">}</span><span class="s1">. The following axis names (e.g. defined &#39;</span>
      <span class="sa">f</span><span class="s1">&#39;by pmap) are available to collective operations: </span><span class="si">{</span><span class="n">named_axes</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">NamedAxisEffect</span><span class="p">(</span><span class="n">effects</span><span class="o">.</span><span class="n">Effect</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;A side-effect introducing a new named axis into the current scope.&quot;&quot;&quot;</span>

  <span class="n">name</span><span class="p">:</span> <span class="n">AxisName</span>


<span class="n">effects</span><span class="o">.</span><span class="n">control_flow_allowed_effects</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="n">NamedAxisEffect</span><span class="p">)</span>
<span class="n">effects</span><span class="o">.</span><span class="n">custom_derivatives_allowed_effects</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="n">NamedAxisEffect</span><span class="p">)</span>
<span class="n">effects</span><span class="o">.</span><span class="n">lowerable_effects</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="n">NamedAxisEffect</span><span class="p">)</span>
<span class="n">effects</span><span class="o">.</span><span class="n">remat_allowed_effects</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="n">NamedAxisEffect</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">filter_named_axis_effects</span><span class="p">(</span>
    <span class="n">effects</span><span class="p">:</span> <span class="n">Effects</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">AxisName</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Effects</span><span class="p">:</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">effects</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">NamedAxisEffect</span><span class="p">)</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">remove_named_axis_effects</span><span class="p">(</span>
    <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">AxisName</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Jaxpr</span><span class="p">:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">names</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">jaxpr</span>
  <span class="k">return</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">effects</span><span class="o">=</span><span class="n">filter_named_axis_effects</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span> <span class="n">names</span><span class="p">))</span>


<span class="n">ParamDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="n">AxisSubst</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">AxisName</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AxisName</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>

<span class="k">class</span> <span class="nc">NameGatheringSubst</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">axis_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
  <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">axis_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">axis_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">axis_name</span><span class="p">,)</span>

<span class="k">def</span> <span class="nf">used_axis_names</span><span class="p">(</span><span class="n">primitive</span><span class="p">:</span> <span class="n">Primitive</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">ParamDict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">AxisName</span><span class="p">]:</span>
  <span class="n">subst</span> <span class="o">=</span> <span class="n">NameGatheringSubst</span><span class="p">()</span>
  <span class="n">subst_axis_names</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">subst</span><span class="o">.</span><span class="n">axis_names</span>

<span class="k">def</span> <span class="nf">subst_axis_names</span><span class="p">(</span><span class="n">primitive</span><span class="p">:</span> <span class="n">Primitive</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">ParamDict</span><span class="p">,</span> <span class="n">subst</span><span class="p">:</span> <span class="n">AxisSubst</span><span class="p">,</span> <span class="n">traverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamDict</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">primitive</span> <span class="ow">in</span> <span class="n">axis_substitution_rules</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">axis_substitution_rules</span><span class="p">[</span><span class="n">primitive</span><span class="p">](</span><span class="n">params</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">traverse</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">traverse</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">params</span>
  <span class="c1"># Default implementation: substitute names in all jaxpr parameters</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">MapPrimitive</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">shadowed_subst</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span> <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;axis_name&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">subst</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">shadowed_subst</span> <span class="o">=</span> <span class="n">subst</span>
  <span class="n">jaxpr_params</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">))]</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">jaxpr_params</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">params</span>
  <span class="n">new_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">jaxpr</span> <span class="ow">in</span> <span class="n">jaxpr_params</span><span class="p">:</span>
    <span class="n">new_params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">subst_axis_names_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">shadowed_subst</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_params</span>

<span class="k">class</span> <span class="nc">DuplicateAxisNameError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">var</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">eqn</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">subst_axis_names_effects</span><span class="p">(</span><span class="n">effects</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Effect</span><span class="p">],</span> <span class="n">subst</span><span class="p">:</span> <span class="n">AxisSubst</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Effect</span><span class="p">]:</span>
  <span class="n">new_effects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">[</span><span class="n">Effect</span><span class="p">]()</span>
  <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">effects</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">NamedAxisEffect</span><span class="p">):</span>
      <span class="n">new_effects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">NamedAxisEffect</span><span class="p">,</span> <span class="n">subst</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">new_effects</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_effects</span>

<span class="k">def</span> <span class="nf">subst_axis_names_var</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">,</span> <span class="n">subst</span><span class="p">:</span> <span class="n">AxisSubst</span><span class="p">,</span> <span class="n">var_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Var</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Var</span><span class="p">:</span>
  <span class="c1"># Var identity is load-bearing, so we can&#39;t have duplicates!</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DropVar</span><span class="p">):</span> <span class="k">return</span> <span class="n">v</span>
  <span class="k">assert</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_map</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="s1">&#39;named_shape&#39;</span><span class="p">):</span>
    <span class="n">var_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">v</span>
  <span class="n">names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">subst</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">named_shape</span><span class="p">))</span>
  <span class="n">named_shape</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">axis_frame</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">}</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">named_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">DuplicateAxisNameError</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="n">new_v</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">suffix</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">named_shape</span><span class="o">=</span><span class="n">named_shape</span><span class="p">))</span>
  <span class="n">var_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_v</span>
  <span class="k">return</span> <span class="n">new_v</span>

<span class="k">def</span> <span class="nf">subst_axis_names_eqn</span><span class="p">(</span><span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">subst</span><span class="p">:</span> <span class="n">AxisSubst</span><span class="p">,</span> <span class="n">var_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Var</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">JaxprEqn</span><span class="p">:</span>
  <span class="n">invars</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Literal</span><span class="p">)</span> <span class="k">else</span> <span class="n">var_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">]</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">outvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">subst_axis_names_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">var_map</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">]</span>
  <span class="k">except</span> <span class="n">DuplicateAxisNameError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">e</span><span class="o">.</span><span class="n">eqn</span> <span class="o">=</span> <span class="n">eqn</span>
    <span class="k">raise</span>
  <span class="n">params</span> <span class="o">=</span> <span class="n">subst_axis_names</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>
  <span class="n">effects</span> <span class="o">=</span> <span class="n">subst_axis_names_effects</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">eqn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">invars</span><span class="o">=</span><span class="n">invars</span><span class="p">,</span> <span class="n">outvars</span><span class="o">=</span><span class="n">outvars</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">effects</span><span class="o">=</span><span class="n">effects</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">do_subst_axis_names_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span> <span class="o">|</span> <span class="n">ClosedJaxpr</span><span class="p">,</span> <span class="n">subst</span><span class="p">:</span> <span class="n">AxisSubst</span><span class="p">):</span>
  <span class="n">consts</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">):</span>
    <span class="n">consts</span> <span class="o">=</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">consts</span>
    <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">jaxpr</span>
  <span class="n">var_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">invars</span> <span class="o">=</span> <span class="p">[</span><span class="n">subst_axis_names_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">var_map</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">]</span>  <span class="c1"># type: ignore[union-attr]</span>
  <span class="n">constvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">subst_axis_names_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">var_map</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">]</span>  <span class="c1"># type: ignore[union-attr]</span>
  <span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">subst_axis_names_eqn</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">var_map</span><span class="p">)</span> <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">]</span>  <span class="c1"># type: ignore[union-attr]</span>
  <span class="n">outvars</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Literal</span><span class="p">)</span> <span class="k">else</span> <span class="n">var_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">]</span>  <span class="c1"># type: ignore[union-attr]</span>
  <span class="n">effects</span> <span class="o">=</span> <span class="n">subst_axis_names_effects</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>
  <span class="n">new_jaxpr</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">constvars</span><span class="p">,</span> <span class="n">invars</span><span class="p">,</span> <span class="n">outvars</span><span class="p">,</span> <span class="n">eqns</span><span class="p">,</span> <span class="n">effects</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">consts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_jaxpr</span>

<span class="k">def</span> <span class="nf">used_axis_names_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span> <span class="o">|</span> <span class="n">ClosedJaxpr</span><span class="p">):</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">e</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">NamedAxisEffect</span><span class="p">)}</span>

<span class="k">def</span> <span class="nf">subst_axis_names_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span> <span class="o">|</span> <span class="n">ClosedJaxpr</span><span class="p">,</span> <span class="n">subst</span><span class="p">:</span> <span class="n">AxisSubst</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subst</span><span class="p">,</span> <span class="n">NameGatheringSubst</span><span class="p">):</span>  <span class="c1"># This is a common case, so we optimize it!</span>
    <span class="n">subst</span><span class="o">.</span><span class="n">axis_names</span> <span class="o">|=</span> <span class="n">used_axis_names_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jaxpr</span>
  <span class="k">return</span> <span class="n">do_subst_axis_names_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">replace_jaxpr_effects</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">ClosedJaxpr</span><span class="p">,</span> <span class="n">effects</span><span class="p">:</span> <span class="n">Effects</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_replace_jaxpr_effects</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">effects</span><span class="p">))</span>

<span class="nd">@weakref_lru_cache</span>
<span class="k">def</span> <span class="nf">_replace_jaxpr_effects</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">ClosedJaxpr</span><span class="p">,</span> <span class="n">effects</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">[</span><span class="n">Effect</span><span class="p">]):</span>
  <span class="k">return</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">effects</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">effects</span><span class="p">)))</span>


<span class="n">axis_substitution_rules</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Primitive</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ParamDict</span><span class="p">,</span> <span class="n">AxisSubst</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="n">ParamDict</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># ------------------- AxisPrimitive -------------------</span>
<span class="c1"># Primitives that store axis names in params and want those axis names to</span>
<span class="c1"># participate in dispatch should subclass AxisPrimitive.</span>

<span class="k">class</span> <span class="nc">AxisPrimitive</span><span class="p">(</span><span class="n">Primitive</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="n">top_trace</span> <span class="o">=</span> <span class="n">find_top_trace</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">axis_main</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">axis_frame</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">main_trace</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">used_axis_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">)),</span>
                    <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;level&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">top_trace</span> <span class="o">=</span> <span class="p">(</span><span class="n">top_trace</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">axis_main</span> <span class="ow">or</span> <span class="n">axis_main</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">top_trace</span><span class="o">.</span><span class="n">level</span>
                 <span class="k">else</span> <span class="n">axis_main</span><span class="o">.</span><span class="n">with_cur_sublevel</span><span class="p">())</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind_with_trace</span><span class="p">(</span><span class="n">top_trace</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>


<span class="c1"># ------------------- Jaxpr checking -------------------</span>

<span class="k">def</span> <span class="nf">typecheck</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">typecompat</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">typecompat</span><span class="p">(</span><span class="n">aval_ref</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Determine whether `aval` conforms to `aval_ref`.</span>

<span class="sd">  Ignores weak_type and named_shape, other than to check that an axis name isn&#39;t</span>
<span class="sd">  used with different sizes.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">typematch</span><span class="p">(</span><span class="n">aval_ref</span><span class="p">,</span> <span class="n">lattice_join</span><span class="p">(</span><span class="n">aval_ref</span><span class="p">,</span> <span class="n">aval</span><span class="p">))</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">typematch</span><span class="p">(</span><span class="n">aval1</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">,</span> <span class="n">aval2</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Determine whether `aval1` and `aval2` are equivalent.</span>

<span class="sd">  Ignores weak_type and named_shape, other than to check that an axis name isn&#39;t</span>
<span class="sd">  used with different sizes.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">aval1</span> <span class="o">==</span> <span class="n">aval2</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
  <span class="c1"># unequal avals may still represent the same type, because type is represented</span>
  <span class="c1"># by avals at the shaped level, and because weak type tags and (for now) named</span>
  <span class="c1"># shape components aren&#39;t considered part of the type</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aval1</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aval2</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">):</span>
    <span class="c1"># a bonus check for whether any named axes have inconsistent sizes</span>
    <span class="n">join_named_shapes</span><span class="p">(</span><span class="n">aval1</span><span class="o">.</span><span class="n">named_shape</span><span class="p">,</span> <span class="n">aval2</span><span class="o">.</span><span class="n">named_shape</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">aval1</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">strip_named_shape</span><span class="p">()</span> <span class="o">==</span>
          <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">aval2</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">strip_named_shape</span><span class="p">())</span>

<span class="k">class</span> <span class="nc">JaxprTypeError</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">custom_typechecks</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Primitive</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">_check_closed_call</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="o">*</span><span class="n">in_atoms</span><span class="p">,</span> <span class="n">call_jaxpr</span><span class="p">):</span>
  <span class="n">in_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">in_atoms</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_avals</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="s2">&quot;Closed call in_avals mismatch&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">,</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">effects</span>
<span class="n">custom_typechecks</span><span class="p">[</span><span class="n">closed_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_check_closed_call</span>

<span class="k">def</span> <span class="nf">check_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Checks well-formedness of a jaxpr.</span>

<span class="sd">  Specifically, check that:</span>
<span class="sd">  - variables that are read are bound beforehand</span>
<span class="sd">  - variables are typed equally throughout a jaxpr</span>
<span class="sd">  - variable type annotations are compatible with their binding expression</span>

<span class="sd">  Raises `JaxprTypeError` if `jaxpr` is determined invalid. Returns `None`</span>
<span class="sd">  otherwise.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="nd">@functools</span><span class="o">.</span><span class="n">cache</span>
  <span class="k">def</span> <span class="nf">ctx_factory</span><span class="p">():</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">JaxprPpContext</span><span class="p">()</span>
    <span class="n">pp_settings</span> <span class="o">=</span> <span class="n">JaxprPpSettings</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">pp_settings</span><span class="p">)</span>  <span class="c1"># side-effect on ctx, build variable names</span>
    <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
    <span class="k">return</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">pp_settings</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="n">_check_jaxpr</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">)</span>
  <span class="k">except</span> <span class="n">JaxprTypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">ctx</span><span class="p">,</span> <span class="n">pp_settings</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">msg</span><span class="p">,</span> <span class="n">eqnidx</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span>
      <span class="n">jaxpr_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp_jaxpr_eqn_range</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">eqnidx</span> <span class="o">-</span> <span class="mi">10</span><span class="p">,</span> <span class="n">eqnidx</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span>
                                         <span class="n">pp_settings</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">msg</span><span class="p">,</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span>
      <span class="n">jaxpr_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp_jaxpr_eqn_range</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">pp_settings</span><span class="p">))</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">msg</span><span class="p">,</span> <span class="s2">&quot;while checking jaxpr:&quot;</span><span class="p">,</span> <span class="n">jaxpr_str</span><span class="p">])</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

  <span class="c1"># Run key reuse checker after validating jaxpr:</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">debug_key_reuse</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
    <span class="c1"># Import here to avoid circular imports</span>
    <span class="kn">from</span> <span class="nn">jax.experimental.key_reuse._core</span> <span class="kn">import</span> <span class="n">check_key_reuse_jaxpr</span>  <span class="c1"># pytype: disable=import-error</span>
    <span class="n">check_key_reuse_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_jaxpr</span><span class="p">(</span>
    <span class="n">ctx_factory</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">JaxprPpSettings</span><span class="p">]],</span>
    <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
  <span class="c1"># Use set of variables to types to check that variables are in scope.</span>
  <span class="n">env</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Atom</span><span class="p">:</span>
    <span class="c1"># Check the type annotation is itself well-typed.</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Var</span><span class="p">):</span>
      <span class="c1"># Check the variable is in-scope and consistently typed.</span>
      <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span>
        <span class="n">ctx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
        <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">pp_var</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; not defined&quot;</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
      <span class="c1"># Check that the literal matches its type annotation.</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">typecheck</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="p">):</span>
        <span class="n">ctx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
        <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Literal value </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s2"> does not match its type annotation &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pp_aval</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;syntactically invalid jaxpr&quot;</span>

  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Var</span><span class="p">),</span> <span class="s2">&quot;syntactically invalid jaxpr&quot;</span>
    <span class="c1"># Check the type annotation of the binder is itself well-typed.</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
    <span class="c1"># Check that the variable is not already bound.</span>
    <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span>
      <span class="n">ctx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
      <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">pp_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; already bound&quot;</span><span class="p">)</span>
    <span class="c1"># Check that the computed type is consistent with the binder annotation.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">typematch</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
      <span class="n">ctx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
      <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span>
          <span class="sa">f</span><span class="s2">&quot;Value for variable &#39;</span><span class="si">{</span><span class="n">pp_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; inconsistently typed &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;as </span><span class="si">{</span><span class="n">pp_aval</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2"> for let-binder of type </span><span class="si">{</span><span class="n">pp_aval</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># If the variable is not a DropVar, add it to the environment.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DropVar</span><span class="p">):</span>
      <span class="n">env</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

  <span class="c1"># Check type annotations on lambda binders.</span>
  <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">):</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
    <span class="n">write</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>

  <span class="c1"># Check each eqn.</span>
  <span class="n">sentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
  <span class="n">in_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">))}</span>
  <span class="k">for</span> <span class="n">eqn_idx</span><span class="p">,</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">):</span>
    <span class="n">prim</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">in_atoms</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">)</span>
      <span class="n">in_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">in_atoms</span><span class="p">]</span>  <span class="c1"># use in_atoms for dyn shapes</span>

      <span class="c1"># Compute the type of the primitive application.</span>
      <span class="k">if</span> <span class="n">prim</span> <span class="ow">in</span> <span class="n">custom_typechecks</span><span class="p">:</span>
        <span class="n">out_type</span><span class="p">,</span> <span class="n">eqn_effects</span> <span class="o">=</span> <span class="n">custom_typechecks</span><span class="p">[</span><span class="n">prim</span><span class="p">](</span>
          <span class="n">ctx_factory</span><span class="p">,</span> <span class="o">*</span><span class="n">in_atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">prim</span><span class="o">.</span><span class="n">call_primitive</span><span class="p">:</span>
        <span class="n">out_type</span><span class="p">,</span> <span class="n">eqn_effects</span> <span class="o">=</span> <span class="n">_check_call</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">in_atoms</span><span class="p">,</span>
                                            <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">prim</span><span class="o">.</span><span class="n">map_primitive</span><span class="p">:</span>
        <span class="n">out_type</span><span class="p">,</span> <span class="n">eqn_effects</span> <span class="o">=</span> <span class="n">_check_map</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span>
                                           <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">out_type</span><span class="p">,</span> <span class="n">eqn_effects</span> <span class="o">=</span> <span class="n">check_eqn</span><span class="p">(</span><span class="n">prim</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

      <span class="c1"># Check the computed effect type matches the eqn&#39;s annotation, and is</span>
      <span class="c1"># included in the jaxpr&#39;s annotation.</span>
      <span class="k">if</span> <span class="n">prim</span> <span class="ow">is</span> <span class="n">mutable_array_p</span><span class="p">:</span>
        <span class="n">outvar</span><span class="p">,</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span>
        <span class="n">in_idx</span><span class="p">[</span><span class="n">outvar</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>
      <span class="k">if</span> <span class="n">eqn</span><span class="o">.</span><span class="n">effects</span> <span class="o">!=</span> <span class="n">eqn_effects</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="s2">&quot;Inferred effects do not match equation effects. &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Equation effects: </span><span class="si">{</span><span class="n">eqn</span><span class="o">.</span><span class="n">effects</span><span class="si">}</span><span class="s2">. &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Inferred effects: </span><span class="si">{</span><span class="n">eqn_effects</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">eff</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">effects</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eff</span><span class="p">,</span> <span class="n">effects</span><span class="o">.</span><span class="n">JaxprInputEffect</span><span class="p">):</span>
          <span class="n">eqn_invar</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">[</span><span class="n">eff</span><span class="o">.</span><span class="n">input_index</span><span class="p">]</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">jaxpr_index</span> <span class="o">:=</span> <span class="n">in_idx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">eqn_invar</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">))</span> <span class="ow">is</span> <span class="n">sentinel</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid `JaxprInputEffect`: must correspond to a jaxpr invar&quot;</span><span class="p">)</span>
          <span class="n">jaxpr_effect</span> <span class="o">=</span> <span class="n">eff</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">input_index</span><span class="o">=</span><span class="n">jaxpr_index</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">jaxpr_effect</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid `JaxprInputEffect`: must be present in jaxpr. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">jaxpr_effect</span><span class="si">}</span><span class="s2"> is not in </span><span class="si">{</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eff</span><span class="p">,</span> <span class="n">NamedAxisEffect</span><span class="p">):</span>
          <span class="c1"># It is valid for a primitive to discharge the named axis effect.</span>
          <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">eff</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">:</span>
          <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="s2">&quot;Equation effect not present in jaxpr effects. &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;Equation effect: </span><span class="si">{</span><span class="n">eff</span><span class="si">}</span><span class="s2">. &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;Jaxpr effects: </span><span class="si">{</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

      <span class="c1"># Check out_type matches the let-binders&#39; annotation (after substitution).</span>
      <span class="n">out_type</span> <span class="o">=</span> <span class="n">substitute_vars_in_output_ty</span><span class="p">(</span><span class="n">out_type</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">)</span>
      <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">out_type</span><span class="p">)</span>

    <span class="k">except</span> <span class="n">JaxprTypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="n">ctx</span><span class="p">,</span> <span class="n">settings</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
      <span class="n">msg</span><span class="p">,</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span>
      <span class="n">src</span> <span class="o">=</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">msg</span><span class="p">,</span> <span class="s2">&quot;in equation:&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp_eqn</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">settings</span><span class="p">))),</span>
                         <span class="sa">f</span><span class="s2">&quot;from source: </span><span class="si">{</span><span class="n">src</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>
      <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">eqn_idx</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

  <span class="c1"># TODO(mattjj): include output type annotation on jaxpr and check it here</span>
  <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">check_type</span><span class="p">(</span>
    <span class="n">ctx_factory</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">JaxprPpSettings</span><span class="p">]],</span>
    <span class="n">env</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Var</span><span class="p">],</span>
    <span class="n">ty</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">,</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ty</span><span class="p">,</span> <span class="n">DShapedArray</span><span class="p">):</span>
    <span class="c1"># Check all elements in the shape tuple are well-typed.</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ty</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span>
          <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">DArray</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">==</span> <span class="n">bint</span><span class="p">):</span>
        <span class="k">continue</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Var</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span>
          <span class="n">ctx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
          <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unbound axis size: &#39;</span><span class="si">{</span><span class="n">pp_var</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="n">DShapedArray</span><span class="p">)):</span>
          <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis size with unexpected type annotation: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="si">}</span><span class="s2"> of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">):</span>
          <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span>
          <span class="k">if</span> <span class="n">shape</span><span class="p">:</span> <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis size nonscalar: </span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis size with non-integer dtype: </span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">DShapedArray</span><span class="p">)</span>
          <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span>
          <span class="k">if</span> <span class="n">shape</span><span class="p">:</span> <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis size nonscalar: </span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
          <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">bint</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;DArray axis size with non-bint dtype: </span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unexpected type in shape: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span>  <span class="c1"># Except in above case(s), all syntactic forms are valid</span>

<span class="k">def</span> <span class="nf">substitute_vars_in_output_ty</span><span class="p">(</span>
    <span class="n">out_type</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">AbstractValue</span><span class="p">],</span>  <span class="c1"># shapes may contain InDBIdx / OutDBIdx</span>
    <span class="n">in_atoms</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Atom</span><span class="p">],</span>
    <span class="n">out_binders</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Var</span><span class="p">],</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">AbstractValue</span><span class="p">]:</span>  <span class="c1"># shapes may contain Vars</span>
  <span class="n">in_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">val</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Literal</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">in_atoms</span><span class="p">]</span>
  <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">out_type</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="ow">is</span> <span class="n">DShapedArray</span><span class="p">:</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">in_atoms</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">InDBIdx</span> <span class="k">else</span>  <span class="c1"># type: ignore</span>
               <span class="n">out_binders</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">OutDBIdx</span> <span class="k">else</span>  <span class="c1"># type: ignore</span>
               <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
      <span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">check_eqn</span><span class="p">(</span><span class="n">prim</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">jaxpr</span> <span class="ow">in</span> <span class="n">jaxprs_in_params</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="n">check_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>

  <span class="n">out_avals</span><span class="p">,</span> <span class="n">effects</span> <span class="o">=</span> <span class="n">prim</span><span class="o">.</span><span class="n">abstract_eval</span><span class="p">(</span><span class="o">*</span><span class="n">in_avals</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">prim</span><span class="o">.</span><span class="n">multiple_results</span><span class="p">:</span>
    <span class="n">out_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">out_avals</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">effects</span>

<span class="k">def</span> <span class="nf">_check_call</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">in_atoms</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
  <span class="k">if</span> <span class="s2">&quot;call_jaxpr&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Call primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> missing &#39;call_jaxpr&#39; parameter&quot;</span><span class="p">)</span>
  <span class="n">call_jaxpr</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;call_jaxpr&quot;</span><span class="p">]</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Call primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">in_atoms</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;operands cannot call jaxpr with &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">)</span><span class="si">}</span><span class="s2"> inputs&quot;</span><span class="p">)</span>

  <span class="c1"># Check `call_jaxpr` can be applied to in_atoms.</span>
  <span class="n">env</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Atom</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">def</span> <span class="nf">substitute</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">DShapedArray</span><span class="p">):</span>
      <span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
    <span class="k">return</span> <span class="n">aval</span>
  <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">in_atoms</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">typecompat</span><span class="p">(</span><span class="n">substitute</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">):</span>
      <span class="c1"># TODO(mattjj): vars in error message are confusing b/c of Var.__repr__</span>
      <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Call primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> passes operand </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> of type &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="si">}</span><span class="s2"> to jaxpr expecting type &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">substitute</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span>

  <span class="n">_check_jaxpr</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">call_jaxpr</span><span class="p">)</span>

  <span class="n">invars</span><span class="p">,</span> <span class="n">outvars</span> <span class="o">=</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">outvars</span>
  <span class="n">in_map</span> <span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span>  <span class="n">InDBIdx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span>  <span class="n">InDBIdx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">invars</span><span class="p">)}</span>
  <span class="n">out_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">OutDBIdx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">OutDBIdx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outvars</span><span class="p">)</span>
                                  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span><span class="p">}</span>
  <span class="n">out_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">]</span>
  <span class="n">out_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">in_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">out_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
                                   <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
              <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">DShapedArray</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">out_avals</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">out_type</span><span class="p">,</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">effects</span>

<span class="k">def</span> <span class="nf">_check_map</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
  <span class="k">if</span> <span class="s2">&quot;call_jaxpr&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Map primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> missing &#39;call_jaxpr&#39; parameter&quot;</span><span class="p">)</span>
  <span class="n">call_jaxpr</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;call_jaxpr&quot;</span><span class="p">]</span>
  <span class="n">ordered_effects_</span> <span class="o">=</span> <span class="n">effects</span><span class="o">.</span><span class="n">ordered_effects</span><span class="o">.</span><span class="n">filter_in</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ordered_effects_</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Map primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> mapping ordered effects: </span><span class="si">{</span><span class="n">ordered_effects_</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="s2">&quot;axis_size&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Map primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> missing &#39;axis_size&#39; parameter&quot;</span><span class="p">)</span>
  <span class="n">axis_size</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;axis_size&quot;</span><span class="p">]</span>
  <span class="k">if</span> <span class="s2">&quot;axis_name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Map primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> missing &#39;axis_name&#39; parameter&quot;</span><span class="p">)</span>
  <span class="n">axis_name</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;axis_name&quot;</span><span class="p">]</span>
  <span class="k">if</span> <span class="s2">&quot;in_axes&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Map primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> missing &#39;in_axes&#39; parameter&quot;</span><span class="p">)</span>
  <span class="n">in_axes</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;in_axes&quot;</span><span class="p">]</span>
  <span class="k">if</span> <span class="s2">&quot;out_axes&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Map primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> missing &#39;out_axes&#39; parameter&quot;</span><span class="p">)</span>
  <span class="n">out_axes</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;out_axes&quot;</span><span class="p">]</span>

  <span class="n">binder_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">unmapped_aval</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">in_axis</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
                  <span class="k">if</span> <span class="n">in_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span>
                  <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">in_axis</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">in_axes</span><span class="p">)]</span>
  <span class="k">for</span> <span class="n">binder_aval</span><span class="p">,</span> <span class="n">in_aval</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">binder_avals</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">typecompat</span><span class="p">(</span><span class="n">binder_aval</span><span class="p">,</span> <span class="n">in_aval</span><span class="p">):</span>
      <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Call primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> passes operand </span><span class="si">{</span><span class="n">in_aval</span><span class="si">}</span><span class="s2"> &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;to jaxpr expecting </span><span class="si">{</span><span class="n">binder_aval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">with</span> <span class="n">extend_axis_env</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;axis_name&#39;</span><span class="p">],</span> <span class="n">axis_size</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">_check_jaxpr</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">call_jaxpr</span><span class="p">)</span>

  <span class="n">mapped_out_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">]</span>
  <span class="n">out_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">unmapped_aval</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">out_axis</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">out_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">aval</span>
               <span class="k">for</span> <span class="n">aval</span><span class="p">,</span> <span class="n">out_axis</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mapped_out_avals</span><span class="p">,</span> <span class="n">out_axes</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">filter_named_axis_effects</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span> <span class="p">{</span><span class="n">axis_name</span><span class="p">})</span>


<span class="c1"># ------------------- Jaxpr printed representation -------------------</span>


<span class="k">class</span> <span class="nc">JaxprPpSettings</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">print_shapes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">source_info</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="n">name_stack</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="n">custom_pp_eqn_rules</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">print_effects</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">_encode_digits_alphabetic</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">&#39;*&#39;</span>
  <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
  <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span><span class="p">:</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">26</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">26</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">97</span> <span class="o">+</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">26</span><span class="p">)</span> <span class="o">+</span> <span class="n">s</span>
  <span class="k">return</span> <span class="n">s</span>

<span class="c1"># A JaxprPpContext allows us to globally uniquify variable names within nested</span>
<span class="c1"># Jaxprs.</span>
<span class="k">class</span> <span class="nc">JaxprPpContext</span><span class="p">:</span>
  <span class="n">var_names</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
  <span class="n">used_names</span><span class="p">:</span> <span class="n">MutableSet</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
  <span class="n">top_level_jaxprs</span><span class="p">:</span> <span class="n">MutableMapping</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">top_level_jaxprs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">used_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">fresh_names</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">name</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">:=</span> <span class="n">_encode_digits_alphabetic</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">used_names</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">fresh_names</span><span class="o">.</span><span class="fm">__next__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pp_var</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">Literal</span><span class="p">,</span> <span class="n">DropVar</span><span class="p">)):</span> <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">context</span><span class="o">.</span><span class="n">var_names</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="si">}{</span><span class="n">v</span><span class="o">.</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="k">def</span> <span class="nf">pp_aval</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">DShapedArray</span><span class="p">):</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">pp_var</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">_short_dtype_name</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s1">]&#39;</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">str_short</span><span class="p">(</span><span class="n">short_dtypes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pp_vars</span><span class="p">(</span><span class="n">vs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">print_shapes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">print_shapes</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">()),</span> <span class="p">[</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">pp_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">context</span><span class="p">))</span> <span class="o">+</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">type_annotation</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="n">pp_aval</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">context</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span>
      <span class="p">])</span>
    <span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">()),</span>
              <span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">pp_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">context</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">])</span>
    <span class="p">))</span>

<span class="k">def</span> <span class="nf">pp_kv_pair</span><span class="p">(</span><span class="n">k</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">v</span><span class="p">):</span>
    <span class="n">pp_v</span> <span class="o">=</span> <span class="n">pp_jaxprs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">):</span>
    <span class="n">pp_v</span> <span class="o">=</span> <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">):</span>
    <span class="n">pp_v</span> <span class="o">=</span> <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">pp_v</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">=&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp_v</span>

<span class="k">def</span> <span class="nf">pp_kv_pairs</span><span class="p">(</span><span class="n">kv_pairs</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">kv_pairs</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">nil</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">),</span>  <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">),</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span> <span class="p">[</span><span class="n">pp_kv_pair</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kv_pairs</span><span class="p">])</span>
    <span class="p">]))</span>
    <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)</span>
  <span class="p">)</span>

<span class="k">def</span> <span class="nf">pp_eqn</span><span class="p">(</span><span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span>
           <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="n">rule</span> <span class="o">=</span> <span class="p">(</span><span class="n">_pp_eqn</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">settings</span><span class="o">.</span><span class="n">custom_pp_eqn_rules</span> <span class="k">else</span>
          <span class="n">pp_eqn_rules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="n">_pp_eqn</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">rule</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>  <span class="c1"># type: ignore[operator]</span>

<span class="k">def</span> <span class="nf">_pp_eqn</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="n">annotation</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_info_util</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">source_info</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">params</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
  <span class="n">name_stack_annotation</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="o">.</span><span class="n">name_stack</span><span class="si">}</span><span class="s1">]&#39;</span> <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">name_stack</span> <span class="k">else</span> <span class="kc">None</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">print_shapes</span><span class="p">)</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">name_stack_annotation</span><span class="p">),</span>
         <span class="n">pp_kv_pairs</span><span class="p">([(</span><span class="n">p</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">],</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">),</span>
         <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">context</span><span class="p">)]</span>
  <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">format</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">lhs</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; = &quot;</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">),</span> <span class="o">*</span><span class="n">rhs</span><span class="p">])</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
<span class="n">CustomPpEqnRule</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">JaxprPpSettings</span><span class="p">],</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">]</span>
<span class="n">pp_eqn_rules</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Primitive</span><span class="p">,</span> <span class="n">CustomPpEqnRule</span><span class="p">]</span>  <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">pp_eqns</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(</span><span class="s2">&quot;; &quot;</span><span class="p">),</span>
    <span class="p">[</span><span class="n">pp_eqn</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">eqns</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">_compact_eqn_should_include</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;branches&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">)):</span> <span class="k">return</span> <span class="kc">False</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span>
      <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)):</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">str_eqn_compact</span><span class="p">(</span><span class="n">primitive_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="s2">&quot;Compact equation to string conversion used in HLO metadata.&quot;</span>
  <span class="n">kvs</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                 <span class="k">if</span> <span class="n">_compact_eqn_should_include</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
  <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">primitive_name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">kvs</span><span class="si">}</span><span class="s2">]&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kvs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">primitive_name</span>

<span class="k">def</span> <span class="nf">pp_jaxpr_skeleton</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">eqns_fn</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span>
                      <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="n">constvars</span> <span class="o">=</span> <span class="n">pp_vars</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">print_shapes</span><span class="p">)</span>
  <span class="n">invars</span> <span class="o">=</span> <span class="n">pp_vars</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">print_shapes</span><span class="p">)</span>
  <span class="n">eqns</span> <span class="o">=</span> <span class="n">eqns_fn</span><span class="p">()</span>
  <span class="n">outvars</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">),</span> <span class="n">pp_vars</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">),</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;)&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;,)&quot;</span><span class="p">)])</span>
  <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">print_effects</span><span class="p">:</span>
    <span class="c1"># TODO(sharadmv): render an entire signature here</span>
    <span class="n">eff_text</span> <span class="o">=</span> <span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; : { &quot;</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">eff_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">))</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eff</span><span class="p">,</span> <span class="n">effects</span><span class="o">.</span><span class="n">JaxprInputEffect</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">eff</span><span class="o">.</span><span class="n">input_index</span>
        <span class="n">all_vars</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">,</span> <span class="o">*</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">]</span>
        <span class="n">eff_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp_effect</span><span class="p">(</span><span class="n">eff</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">input_index</span><span class="o">=</span><span class="n">all_vars</span><span class="p">[</span><span class="n">index</span><span class="p">]),</span>
                                  <span class="n">context</span><span class="p">))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">eff_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp_effect</span><span class="p">(</span><span class="n">eff</span><span class="p">,</span> <span class="n">context</span><span class="p">))</span>
    <span class="n">eff_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; }&quot;</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">eff_text</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;{ &quot;</span><span class="p">),</span> <span class="n">pp</span><span class="o">.</span><span class="n">keyword</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;lambda &quot;</span><span class="p">)),</span>
    <span class="n">constvars</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;; &quot;</span><span class="p">),</span> <span class="n">invars</span><span class="p">,</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;. &quot;</span><span class="p">),</span> <span class="n">pp</span><span class="o">.</span><span class="n">keyword</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;let&quot;</span><span class="p">)),</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">()</span> <span class="o">+</span> <span class="n">eqns</span><span class="p">),</span> <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">keyword</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;in &quot;</span><span class="p">)),</span> <span class="n">outvars</span><span class="p">,</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">eff_text</span><span class="p">)</span>
  <span class="p">]))</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; }&quot;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">pp_top_level_jaxpr</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span>
    <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span>
    <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;let &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; = &quot;</span><span class="p">),</span>
      <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">),</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; in&quot;</span><span class="p">),</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span>
  <span class="p">])</span>


<span class="k">def</span> <span class="nf">pp_jaxpr</span><span class="p">(</span>
    <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span>
    <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span>
    <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">name</span> <span class="o">:=</span> <span class="n">context</span><span class="o">.</span><span class="n">top_level_jaxprs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
  <span class="n">eqns_fn</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">pp_eqns</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">pp_jaxpr_skeleton</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">eqns_fn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pp_jaxprs</span><span class="p">(</span><span class="n">jaxprs</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="n">jaxprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span><span class="o">.</span><span class="n">jaxpr</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">)</span> <span class="k">else</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jaxprs</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">),</span> <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">),</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">),</span> <span class="n">jaxprs</span><span class="p">))]</span>
    <span class="p">))</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
  <span class="p">)</span>


<span class="k">def</span> <span class="nf">pp_jaxpr_eqn_range</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">lo</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hi</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span>
                       <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="n">lo</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">hi</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">)))</span>
  <span class="n">eqns</span> <span class="o">=</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">[</span><span class="n">lo</span><span class="p">:</span><span class="n">hi</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">eqns_fn</span><span class="p">():</span>
    <span class="n">pps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eqns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">pps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">lo</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">pps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">))</span>
      <span class="n">pps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">map</span><span class="p">((</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">pp_eqn</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)),</span> <span class="n">eqns</span><span class="p">))</span>
      <span class="k">if</span> <span class="n">hi</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">):</span>
        <span class="n">pps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(</span><span class="s2">&quot;; &quot;</span><span class="p">),</span> <span class="n">pps</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">pp_jaxpr_skeleton</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">eqns_fn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pp_effect</span><span class="p">(</span><span class="n">effect</span><span class="p">:</span> <span class="n">Effect</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">effect</span><span class="p">,</span> <span class="s2">&quot;_pretty_print&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">effect</span><span class="o">.</span><span class="n">_pretty_print</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">effect</span><span class="p">))</span>

<span class="c1"># ------------------- Jaxpr util -------------------</span>

<span class="k">def</span> <span class="nf">last_used</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">JaxprEqn</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Returns a mapping from every var in jaxpr to what equation uses it last.&quot;&quot;&quot;</span>
  <span class="n">last_used</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">JaxprEqn</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="n">v</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Literal</span><span class="p">)}</span>
  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">:</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Literal</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">last_used</span><span class="p">:</span>
        <span class="n">last_used</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">eqn</span>
  <span class="k">return</span> <span class="n">last_used</span>

<span class="k">def</span> <span class="nf">clean_up_dead_vars</span><span class="p">(</span><span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
                       <span class="n">last_used</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">JaxprEqn</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Remove all eqn.invars from env if eqn is the last time they were used.&quot;&quot;&quot;</span>
  <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">{</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Literal</span><span class="p">)}:</span>
    <span class="k">if</span> <span class="n">last_used</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="ow">is</span> <span class="n">eqn</span><span class="p">:</span>
      <span class="c1"># Delete ref to variable when it is no longer needed by next equations.</span>
      <span class="k">del</span> <span class="n">env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By The JAX authors
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      Â© Copyright 2024, The JAX Authors. NumPy and SciPy documentation are copyright the respective authors..
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>